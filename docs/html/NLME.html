

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>NLME integration &mdash; pyDarwin 3.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=06cb746d" />

  
      <script src="_static/documentation_options.js?v=dd1205ac"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Troubleshooting" href="Troubleshooting.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pyDarwin
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">About:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="Algorithms.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="Support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="Releases.html">Releases</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="Examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="Options.html">Options List</a></li>
<li class="toctree-l1"><a class="reference internal" href="API.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="Glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Troubleshooting.html">Troubleshooting</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">NLME integration</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-model-structure-and-statements">Basic Model Structure and Statements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#statements">Statements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blocks">Blocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#comments">Comments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variables">Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#predefined-variables">Predefined Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assignment-statements">Assignment Statements</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#parameter-declarations">Parameter Declarations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#stparm">stparm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixef">fixef</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ranef">ranef</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixed-effects">Fixed Effects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#random-effects">Random Effects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#log-normal-distribution">Log-Normal Distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#normal-distribution">Normal Distribution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bounds">Bounds</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#covariates">Covariates</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#covariate">covariate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fcovariate">fcovariate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interpolate">interpolate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#continuous-covariates">Continuous Covariates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#categorical-covariates">Categorical Covariates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#occasion-covariates-and-inter-occasion-variability-iov">Occasion Covariates and Inter-Occasion Variability (IOV)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#time-varying-covariates">Time-Varying Covariates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#structural-model-definition">Structural Model Definition</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#deriv">deriv</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compartment-models">Compartment Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cfmicro">cfMicro</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cfmacro-and-cfmacro1">cfMacro and cfMacro1</a></li>
<li class="toctree-l3"><a class="reference internal" href="#micro-constants-vs-macro-constants">Micro-Constants vs. Macro-Constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dosepoint">dosepoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="#urinecpt">urinecpt</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#observation-and-error-models">Observation and Error Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#observe">observe</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error">error</a></li>
<li class="toctree-l3"><a class="reference internal" href="#error-models">Error Models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bql-handling">BQL Handling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#finding-extrema-peak-function-and-alternative-methods">Finding Extrema (peak function and alternative methods)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#table-output">Table Output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#delays">Delays</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#delay">delay</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gammadelay">gammaDelay</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delayinfcpt">delayInfCpt</a></li>
<li class="toctree-l3"><a class="reference internal" href="#transit">transit</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#built-in-functions">Built-In Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#built-in-mathematical-functions">Built-In Mathematical Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#link-and-inverse-link-functions">Link and Inverse Link Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#if-and-ternary-operator">if and Ternary Operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logical-operators">Logical Operators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sleep">sleep</a></li>
<li class="toctree-l3"><a class="reference internal" href="#statistical-distribution-functions">Statistical Distribution Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#additional-statements-and-features">Additional Statements and Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#secondary-parameters">Secondary Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-mapping-column-definitions">Data Mapping (Column Definitions)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sequence">sequence</a></li>
<li class="toctree-l3"><a class="reference internal" href="#real-and-double">real and double</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#model-generation-guidelines">Model Generation Guidelines</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Model Generation Guidelines</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#modeling-complex-absorption-schemes">Modeling Complex Absorption Schemes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-simultaneous-parallel-absorption-zero-order-and-first-order">A. Simultaneous (Parallel) Absorption (Zero-Order and First-Order)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-sequential-absorption-zero-order-followed-by-first-order-zofo">B. Sequential Absorption (Zero-Order followed by First-Order - ZOFO)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-splitting-a-single-dose-into-different-administration-profiles-e-g-bolus-infusion">C. Splitting a Single Dose into Different Administration Profiles (e.g., Bolus + Infusion)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-parallel-absorption-with-independent-lag-times">D. Parallel Absorption with Independent Lag Times</a></li>
<li class="toctree-l3"><a class="reference internal" href="#modeling-multiple-elimination-pathways">Modeling Multiple Elimination Pathways</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#introduction-to-metamodels">Introduction to Metamodels</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-metamodel-concept">The Metamodel Concept</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#metamodel-structure">Metamodel Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#metamodel-blocks">Metamodel Blocks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#execution-control-and-output">Execution Control and Output</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#estargs-estimation-engine-arguments">##ESTARGS: Estimation Engine Arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#simargs-simulation-arguments">##SIMARGS: Simulation Arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tables-defining-output-tables">##TABLES: Defining Output Tables</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linking-data-to-the-model">Linking Data to the Model</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#data-mapping-map-and-coldef">Data Mapping: ##MAP and ##COLDEF</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-map-block"><strong>The ##MAP Block</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-coldef-block"><strong>The ##COLDEF Block</strong></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-dosing-and-a-complete-example">Advanced Dosing and a Complete Example</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dosing-cycle">##DOSING CYCLE</a></li>
<li class="toctree-l3"><a class="reference internal" href="#complete-metamodel-example">Complete Metamodel Example</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#automated-model-search-with-pydarwin">Automated Model Search with pyDarwin</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-metamodel-as-a-template-file">The Metamodel as a Template File</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-tokens-json-file">The tokens.json File</a></li>
<li class="toctree-l3"><a class="reference internal" href="#directory-shortcuts-in-templates">Directory Shortcuts in Templates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-pydarwin-execution-options-file">The pyDarwin Execution Options File</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pydarwin-best-practices">pyDarwin Best Practices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-golden-rules-of-metamodel-templates-for-pydarwin">The Golden Rules of Metamodel Templates for pyDarwin</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#automated-search-of-omega-structure">Automated Search of Omega Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#searching-omega-structure-in-nlme-models">Searching Omega Structure in NLME Models</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#basic-omega-block-search"><strong>Basic Omega Block Search</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="#advanced-search-with-submatrices"><strong>Advanced Search with Submatrices</strong></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyDarwin</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">NLME integration</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="nlme-integration">
<h1>NLME integration<a class="headerlink" href="#nlme-integration" title="Link to this heading">¶</a></h1>
<section id="basic-model-structure-and-statements">
<span id="nlme-model-structure"></span><h2>Basic Model Structure and Statements<a class="headerlink" href="#basic-model-structure-and-statements" title="Link to this heading">¶</a></h2>
<p>A PML model defines the structure of a pharmacokinetic/pharmacodynamic model. The basic structure consists of a
main block enclosed in curly braces, typically named <code class="docutils literal notranslate"><span class="pre">test()</span></code>, containing statements that define the model’s components.</p>
<p>The fundamental structure of a PML model is:</p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>modelName() {
  // Statements defining the model
}
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">modelName()</span></code>: The name of the model (e.g., <code class="docutils literal notranslate"><span class="pre">test</span></code>, <code class="docutils literal notranslate"><span class="pre">oneCompartmentModel</span></code>). The parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code> are <em>required</em>.
While any valid name can be used, <code class="docutils literal notranslate"><span class="pre">test()</span></code> is a common convention for simple models.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>: Curly braces define the <em>model block</em>. All model statements must be within this block.</p></li>
<li><p>Statements within the block define the model’s components (e.g., parameters, equations, error models). Statement order is generally
<em>not</em> important, except within <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks and for assignment statements.</p></li>
</ul>
<section id="statements">
<span id="nlme-model-structure-statements"></span><h3>Statements<a class="headerlink" href="#statements" title="Link to this heading">¶</a></h3>
<p>Statements are the building blocks of a PML model. They
define parameters, equations, and other aspects of the model. Statements
can span multiple lines, and semicolons are optional separators.</p>
<ul class="simple">
<li><p><strong>Types of Statements:</strong> PML includes various statement types,
including:</p>
<ul>
<li><p>Assignment statements (e.g., <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">A1</span> <span class="pre">/</span> <span class="pre">V</span></code>)</p></li>
<li><p>Declaration statements (e.g., <code class="docutils literal notranslate"><span class="pre">stparm</span></code>, <code class="docutils literal notranslate"><span class="pre">fixef</span></code>, <code class="docutils literal notranslate"><span class="pre">ranef</span></code>, <code class="docutils literal notranslate"><span class="pre">covariate</span></code>, <code class="docutils literal notranslate"><span class="pre">error</span></code>)</p></li>
<li><p>Control flow statements (within <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks: <code class="docutils literal notranslate"><span class="pre">if</span></code>, <code class="docutils literal notranslate"><span class="pre">while</span></code>, <code class="docutils literal notranslate"><span class="pre">sleep</span></code>)</p></li>
<li><p>Model component statements (e.g., <code class="docutils literal notranslate"><span class="pre">deriv</span></code>, <code class="docutils literal notranslate"><span class="pre">observe</span></code>, <code class="docutils literal notranslate"><span class="pre">multi</span></code>, <code class="docutils literal notranslate"><span class="pre">LL</span></code>, <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code>, <code class="docutils literal notranslate"><span class="pre">cfMicro</span></code>)</p></li>
</ul>
</li>
<li><p><strong>Order:</strong> In general, the order of statements <em>does not matter</em> in
PML, <em>except</em>:</p>
<ul>
<li><p>Within <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks, where statements are executed sequentially.</p></li>
<li><p>For assignment statements, where the order of assignments to the <em>same</em> variable matters.</p></li>
<li><p>When defining micro constants before <code class="docutils literal notranslate"><span class="pre">cfMicro</span></code></p></li>
</ul>
</li>
<li><p><strong>Semicolons:</strong> Semicolons (<code class="docutils literal notranslate"><span class="pre">;</span></code>) are optional separators between statements. They can improve readability but are not required.</p></li>
<li><p><strong>Line Boundaries:</strong> Statements can span multiple lines.</p></li>
</ul>
<p><strong>Keywords:</strong> statement, assignment, declaration, semicolon, order</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure"><span class="std std-ref">PML Model Structure</span></a>, <a class="reference internal" href="#nlme-model-structure-blocks"><span class="std std-ref">Blocks</span></a>, <a class="reference internal" href="#nlme-model-structure-variables"><span class="std std-ref">Variables</span></a>, <a class="reference internal" href="#nlme-model-structure-assignment-statements"><span class="std std-ref">Assignment Statements</span></a></p>
</section>
<section id="blocks">
<span id="nlme-model-structure-blocks"></span><h3>Blocks<a class="headerlink" href="#blocks" title="Link to this heading">¶</a></h3>
<p>Blocks in PML are sets of statements enclosed in curly
braces <code class="docutils literal notranslate"><span class="pre">{}</span></code>. They are used to group related statements and, in the
case of <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks, to define a specific execution order.</p>
<ul class="simple">
<li><p><strong>Main Model Block:</strong> The entire model is enclosed in a block (e.g.,
<code class="docutils literal notranslate"><span class="pre">test()</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>).</p></li>
<li><p><strong>sequence Block:</strong> The <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block is a special type of
block that defines a <em>sequence</em> of statements to be executed in
order, at specific points in time. This is used for handling
discontinuous events and time-dependent actions.</p></li>
<li><p><strong>Other Blocks:</strong> There are no other named blocks besides the main
model block and <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks.</p></li>
<li><p><strong>dobefore, doafter blocks:</strong> used to define some actions related to
dose delivery and observations.</p></li>
</ul>
<p><strong>Example (sequence block):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>sequence {
  A = 10  // Initialize compartment A
  sleep(5) // Wait for 5 time units
  A = A + 5 // Add to compartment A
}
</pre></div>
</div>
<p><strong>Keywords:</strong> block, curly braces, sequence, scope</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure"><span class="std std-ref">PML Model Structure</span></a>, <a class="reference internal" href="#nlme-model-structure-statements"><span class="std std-ref">Statements</span></a>, <a class="mono reference internal" href="#nlme-sequence"><span class="std std-ref">sequence</span></a></p>
</section>
<section id="comments">
<span id="nlme-model-structure-comments"></span><h3>Comments<a class="headerlink" href="#comments" title="Link to this heading">¶</a></h3>
<p>Comments are used to document the PML code, explaining its
purpose and functionality. PML supports three comment styles: R-style,
C-style, and C++-style.</p>
<ul class="simple">
<li><p><strong>R-style:</strong> <code class="docutils literal notranslate"><span class="pre">#</span> <span class="pre">comment</span> <span class="pre">...</span> <span class="pre">end-of-line</span></code> (Everything after <code class="docutils literal notranslate"><span class="pre">#</span></code> on
a line is a comment).</p></li>
<li><p><strong>C-style:</strong> <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">comment</span> <span class="pre">...</span> <span class="pre">*/</span></code> (Multi-line comments, <em>cannot</em> be
nested).</p></li>
<li><p><strong>C++-style:</strong> <code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">comment</span> <span class="pre">...</span> <span class="pre">end-of-line</span></code></p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
  # This is an R-style comment
  /* This is a
     multi-line C-style comment */
  deriv(A = -k * A)  // C++-style comment
  fixef(k = c(,3,))
  x = 5 //valid statement
  y = 1 #valid statement
}
</pre></div>
</div>
<p>Important Note: While semicolons (;) are used as optional statement
separators in PML, they are NOT reliable comment markers. Do not use a
single semicolon to start a comment. The following examples demonstrate
correct and incorrect comment usage:</p>
<p>test() { deriv(A1 = k) stparm(k = tvk) # This works because ‘stparm’ is
valid. ; This is NOT a valid comment and will cause an error # This is a
valid R-style comment. // This is a valid C++-style comment. /* This is
valid C-style multi-line comment. */ fixef(tvk = c(0,1,2)) }</p>
<p><strong>Keywords:</strong> comment, documentation, #, /* */, //</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure"><span class="std std-ref">PML Model Structure</span></a></p>
</section>
<section id="variables">
<span id="nlme-model-structure-variables"></span><h3>Variables<a class="headerlink" href="#variables" title="Link to this heading">¶</a></h3>
<p>Variables in PML represent quantities within the model,
such as parameters, compartment amounts, and concentrations. Variables
can be declared explicitly or defined through assignment.</p>
<ul class="simple">
<li><p><strong>Data Types:</strong> All variables in PML are double-precision
floating-point numbers (you can declare them using <code class="docutils literal notranslate"><span class="pre">real</span></code> or
<code class="docutils literal notranslate"><span class="pre">double</span></code>, which are equivalent).</p></li>
<li><p><strong>Declared Variables:</strong> Introduced by declaration statements like
<code class="docutils literal notranslate"><span class="pre">deriv</span></code>, <code class="docutils literal notranslate"><span class="pre">real</span></code>, <code class="docutils literal notranslate"><span class="pre">stparm</span></code>, <code class="docutils literal notranslate"><span class="pre">sequence</span></code>, and <code class="docutils literal notranslate"><span class="pre">covariate</span></code>.
These can be modified at specific points in time (e.g., within
<code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks). Examples:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">deriv(A</span> <span class="pre">=</span> <span class="pre">-k</span> <span class="pre">*</span> <span class="pre">A)</span></code> (Declares <code class="docutils literal notranslate"><span class="pre">A</span></code> as an integrator variable)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">real(x)</span></code> (Declares <code class="docutils literal notranslate"><span class="pre">x</span></code> as a real variable, modifiable in
<code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stparm(V</span> <span class="pre">=</span> <span class="pre">tvV</span> <span class="pre">*</span> <span class="pre">exp(nV))</span></code> (Declares <code class="docutils literal notranslate"><span class="pre">V</span></code> as a structural
parameter)</p></li>
</ul>
</li>
<li><p><strong>Functional Variables:</strong> Introduced by assignment at the <em>top level</em>
of the model (i.e., not within a <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block). These are
considered to be continuously calculated and cannot be modified
within <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks. Example:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">A</span> <span class="pre">/</span> <span class="pre">V</span></code> (Defines <code class="docutils literal notranslate"><span class="pre">C</span></code> as the concentration, calculated from
<code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">V</span></code>)</p></li>
</ul>
</li>
<li><p><strong>Variable Names:</strong> Variable names must:</p>
<ul>
<li><p>Be case-sensitive</p></li>
<li><p>Not contain special characters like “.”</p></li>
<li><p>Not begin with an underscore “_”</p></li>
</ul>
</li>
<li><p><strong>Predefined variables</strong> PML contains predefined variables like <code class="docutils literal notranslate"><span class="pre">t</span></code></p></li>
</ul>
<p><strong>Keywords:</strong> variable, declaration, assignment, scope, real, double, declared, functional</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure-statements"><span class="std std-ref">Statements</span></a>, <a class="reference internal" href="#nlme-model-structure-assignment-statements"><span class="std std-ref">Assignment Statements</span></a>, <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="mono reference internal" href="#nlme-fixef"><span class="std std-ref">fixef</span></a>, <a class="mono reference internal" href="#nlme-ranef"><span class="std std-ref">ranef</span></a>, <a class="mono reference internal" href="#nlme-deriv"><span class="std std-ref">deriv</span></a>, <a class="mono reference internal" href="#nlme-real"><span class="std std-ref">real</span></a></p>
</section>
<section id="predefined-variables">
<span id="nlme-model-structure-predefined-variables"></span><h3>Predefined Variables<a class="headerlink" href="#predefined-variables" title="Link to this heading">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">t</span></code>. Represents time. This variable is automatically available in <em>time-based models</em> (models containing at least one <code class="docutils literal notranslate"><span class="pre">deriv</span></code>    statement).</p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The use of <code class="docutils literal notranslate"><span class="pre">t</span></code> on the right-hand-side of <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statement is not recommended.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Contrary to some other modeling languages, <code class="docutils literal notranslate"><span class="pre">pi</span></code> (the mathematical constant ≈ 3.14159) is not a predefined
variable in PML. You <em>must</em> define it explicitly (e.g., <code class="docutils literal notranslate"><span class="pre">pi</span> <span class="pre">=</span> <span class="pre">3.141592653589793</span></code>).</p>
</div>
<p><strong>Keywords:</strong> predefined variables, t, time, built-in variables</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure-variables"><span class="std std-ref">Variables</span></a>, <a class="mono reference internal" href="#nlme-deriv"><span class="std std-ref">deriv</span></a></p>
</section>
<section id="assignment-statements">
<span id="nlme-model-structure-assignment-statements"></span><h3>Assignment Statements<a class="headerlink" href="#assignment-statements" title="Link to this heading">¶</a></h3>
<p>Assignment statements are used to define the value of a
variable based on an expression. They use the <code class="docutils literal notranslate"><span class="pre">=</span></code> operator. Variables
defined by top-level assignment are considered continuously calculated.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">variable</span> <span class="pre">=</span> <span class="pre">expression</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expression</span></code> Can be any valid mathematical expression
involving numbers, variables, operators, and functions.</p></li>
<li><p><strong>Top-Level Assignment:</strong> Assignments made at the top level of the
model (outside of <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks) define <em>functional</em> variables.
These are continuously updated as the values of the variables they
depend on change.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Functional variables are analogous to variables defined by simple assignment within NONMEM’s <code class="docutils literal notranslate"><span class="pre">$PK</span></code> or <code class="docutils literal notranslate"><span class="pre">$PRED</span></code> blocks (before the <code class="docutils literal notranslate"><span class="pre">Y=</span></code> line).</p>
</div>
<ul class="simple">
<li><p><strong>Order matters:</strong> The order of the statements matter.</p></li>
<li><p><strong>Multiple assignments:</strong> It is allowable to have multiple assignment
statements assigned to the same variable, in which case the order
between them matters.</p></li>
<li><p><strong>Important Note:</strong> Variables defined and assigned via top-level
assignment <em>cannot</em> be modified within <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
  A = 10        # Assigns the value 10 to A
  V = 5         # Assigns the value 5 to V
  C = A / V     # Calculates C (concentration) continuously
  C = C + 2     # C will be equal to A/V + 2
}
</pre></div>
</div>
<p><strong>Keywords:</strong> assignment, =, equation, expression, continuous</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure-variables"><span class="std std-ref">Variables</span></a>, <a class="reference internal" href="#nlme-model-structure-statements"><span class="std std-ref">Statements</span></a></p>
</section>
</section>
<section id="parameter-declarations">
<span id="nlme-parameter-declarations"></span><h2>Parameter Declarations<a class="headerlink" href="#parameter-declarations" title="Link to this heading">¶</a></h2>
<section id="stparm">
<span id="nlme-stparm"></span><h3>stparm<a class="headerlink" href="#stparm" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">stparm</span></code> statement defines structural parameters in the model, which are the core parameters describing the
pharmacokinetic/pharmacodynamic processes. <code class="docutils literal notranslate"><span class="pre">stparm</span></code> statements can include fixed effects, random effects, and covariate effects.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> Defines structural parameters and their relationships to
fixed effects, random effects, and covariates.</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">stparm(parameter</span> <span class="pre">=</span> <span class="pre">expression)</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">parameter</span></code>: The name of the structural parameter (e.g., <code class="docutils literal notranslate"><span class="pre">V</span></code>,
<code class="docutils literal notranslate"><span class="pre">Cl</span></code>, <code class="docutils literal notranslate"><span class="pre">Ka</span></code>, <code class="docutils literal notranslate"><span class="pre">EC50</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expression</span></code>: An expression defining how the parameter is
calculated. This expression can include:</p>
<ul>
<li><p>Fixed effects (typically named with a <code class="docutils literal notranslate"><span class="pre">tv</span></code> prefix, e.g.,
<code class="docutils literal notranslate"><span class="pre">tvV</span></code>).</p></li>
<li><p>Random effects (typically named with an <code class="docutils literal notranslate"><span class="pre">n</span></code> prefix, e.g.,
<code class="docutils literal notranslate"><span class="pre">nV</span></code>).</p></li>
<li><p>Covariates.</p></li>
<li><p>Mathematical operators and functions.</p></li>
<li><p>Time-dependent logic using the ternary operator (<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>).</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Common Distributions:</strong></p>
<ul>
<li><p><strong>Log-Normal:</strong> <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">tvParameter</span> <span class="pre">*</span> <span class="pre">exp(nParameter)</span></code>
(Parameter is always positive)</p></li>
<li><p><strong>Normal:</strong> <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">tvParameter</span> <span class="pre">+</span> <span class="pre">nParameter</span></code></p></li>
<li><p><strong>Logit-Normal:</strong> <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">ilogit(tvParameter</span> <span class="pre">+</span> <span class="pre">nParameter)</span></code>
(Parameter is between 0 and 1)</p></li>
</ul>
</li>
<li><p><strong>Multiple stparm Statements:</strong> A model can have multiple
<code class="docutils literal notranslate"><span class="pre">stparm</span></code> statements.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">stparm</span></code> defines <em>structural parameters</em>. These are typically the parameters you are interested in estimating.
Variables defined by simple assignment in NONMEM’s <code class="docutils literal notranslate"><span class="pre">$PK</span></code> (before the <code class="docutils literal notranslate"><span class="pre">Y=</span></code> line) should <em>not</em> be defined using <code class="docutils literal notranslate"><span class="pre">stparm</span></code> in PML
unless they are also associated with a <code class="docutils literal notranslate"><span class="pre">fixef</span></code> (and thus represent an estimable parameter – a THETA in NONMEM). If a NONMEM variable is
assigned a value in <code class="docutils literal notranslate"><span class="pre">$PK</span></code> and is <em>not</em> a THETA, represent it in PML with a top-level assignment statement, <em>not</em> with <code class="docutils literal notranslate"><span class="pre">stparm</span></code>.</p>
</div>
<ul class="simple">
<li><p><strong>Execution:</strong> Structural parameter statements are executed before
anything else, except sequence statements to initialize them.</p></li>
<li><p><strong>Conditional Logic:</strong> Use the ternary operator (<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>) for
conditional logic within <code class="docutils literal notranslate"><span class="pre">stparm</span></code> expressions, <em>not</em> <code class="docutils literal notranslate"><span class="pre">if/else</span></code>.</p></li>
<li><p><strong>Important Note:</strong> When using time-dependent logic within
<code class="docutils literal notranslate"><span class="pre">stparm</span></code>, closed-form solutions are not applicable, and the model
will rely on a numerical ODE solver.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>stparm(V  = tvV * exp(nV))                  // Volume (log-normal)
stparm(Ka = tvKa)                            // Absorption rate constant (fixed effect)
stparm(Cl = tvCl * exp(dCldSex1*(Sex==1)) * exp(nCl + nClx0*(Period==1) + nClx1*(Period==2))) // Clearance (log-normal) Example with occasion covariate Period with 2 levels amd categorical covariate Sex with 2 levels
</pre></div>
</div>
<p><strong>Keywords:</strong> structural parameter, stparm, parameter, population, fixed effect, random effect, covariate, IIV</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-fixef"><span class="std std-ref">fixef</span></a>, <a class="mono reference internal" href="#nlme-ranef"><span class="std std-ref">ranef</span></a>, <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="reference internal" href="#nlme-fixed-effects"><span class="std std-ref">Fixed Effects</span></a>, <a class="reference internal" href="#nlme-random-effects"><span class="std std-ref">Random Effects</span></a>, <a class="reference internal" href="#nlme-log-normal-distribution"><span class="std std-ref">Log-Normal Distribution</span></a>, <a class="reference internal" href="#nlme-if-and-ternary-operator"><span class="std std-ref">if and Ternary Operator</span></a></p>
</section>
<section id="fixef">
<span id="nlme-fixef"></span><h3>fixef<a class="headerlink" href="#fixef" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">fixef</span></code> statement defines fixed-effect parameters
(often called “thetas” in NONMEM), representing the typical or
population values of structural parameters. It also allows specifying
initial estimates, bounds, and enabling/disabling fixed effects for
covariate search.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> Defines fixed-effect parameters and their properties.</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">fixef(parameter[(freeze)][(enable=c(int))]</span> <span class="pre">[=</span> <span class="pre">c([lower</span> <span class="pre">bound],[</span> <span class="pre">initial</span> <span class="pre">estimate],[</span> <span class="pre">upper</span> <span class="pre">bound])])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">parameter</span></code>: The name of the fixed-effect parameter (e.g.,
<code class="docutils literal notranslate"><span class="pre">tvV</span></code>, <code class="docutils literal notranslate"><span class="pre">tvCl</span></code>, <code class="docutils literal notranslate"><span class="pre">dCldSex</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">freeze</span></code>: (Optional) If present, the parameter is <em>not</em>
estimated; it’s fixed at its initial estimate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">enable=c(int)</span></code>: (Optional) Controls whether the parameter is
considered during <em>covariate search</em> procedures (0 = disabled, 1 =
enabled). Has no effect on a regular model fit.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">c([lower</span> <span class="pre">bound],[</span> <span class="pre">initial</span> <span class="pre">estimate],[</span> <span class="pre">upper</span> <span class="pre">bound])]</span></code>:
(Optional) Specifies the lower bound, initial estimate, and upper
bound. Any of these can be omitted (using commas as placeholders).
If only one value is given without bounds, it represents the
initial value</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>May use <code class="docutils literal notranslate"><span class="pre">freeze</span></code> for parameters that are defined and assigned values in the NONMEM <code class="docutils literal notranslate"><span class="pre">$PK</span></code> block but are not THETAs (i.e., not estimated),
but probably it is better to use the direct assignment outside fixef/stparm statements</p>
</div>
<ul class="simple">
<li><p><strong>Default Initial Values:</strong> If no initial estimate is provided:</p>
<ul>
<li><p>Covariate effects: Default initial value is 0.</p></li>
<li><p>Other fixed effects: Default initial value is 1.</p></li>
</ul>
</li>
<li><p><strong>Multiple fixef:</strong> It is possible to have more than one <code class="docutils literal notranslate"><span class="pre">fixef</span></code> statement.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>fixef(tvV  = c(0, 10, 100))  // Initial estimate 10, bounds [0, 100]
fixef(tvCl = c(, 5, )) // Initial estimate 5, no bounds
fixef(dCldSex1(enable=c(0)) = c(, 0, )) // Enabled for covariate search, initial estimate 0
</pre></div>
</div>
<p><strong>Keywords:</strong> fixed effect, fixef, population parameter, typical value, initial estimate, bounds, enable</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="mono reference internal" href="#nlme-ranef"><span class="std std-ref">ranef</span></a>, <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="reference internal" href="#nlme-fixed-effects"><span class="std std-ref">Fixed Effects</span></a>, <a class="reference internal" href="#nlme-bounds"><span class="std std-ref">Bounds</span></a></p>
</section>
<section id="ranef">
<span id="nlme-ranef"></span><h3>ranef<a class="headerlink" href="#ranef" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">ranef</span></code> statement defines random-effect parameters
(often called “etas” in NONMEM), representing inter-individual
variability (IIV) in structural parameters. It also defines the
variance-covariance structure of the random effects.</p>
<ul>
<li><p><strong>Purpose:</strong> Defines random effects and their variance-covariance
matrix.</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">ranef(specification)</span></code></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">specification</span></code>: Defines the random effects and their
relationships. Common options include:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">diag(parameter1,</span> <span class="pre">parameter2,</span> <span class="pre">...)</span></code>: Diagonal covariance
matrix (random effects are independent).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">block(parameter1,</span> <span class="pre">parameter2,</span> <span class="pre">...)</span></code>: Full covariance matrix
(random effects can be correlated).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">same(parameter1,</span> <span class="pre">parameter2,</span> <span class="pre">...)</span></code>: Specifies that
parameters share the same variance (and covariance, if within a
<code class="docutils literal notranslate"><span class="pre">block</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">=</span> <span class="pre">c(...)</span></code>: initial estimates for variance/covariance</p></li>
</ul>
</li>
</ul>
</li>
<li><p>The initial estimates are provided for variance-covariance matrix</p></li>
<li><p><strong>Multiple ranef Statements:</strong> A model can have multiple <code class="docutils literal notranslate"><span class="pre">ranef</span></code> statements.</p></li>
<li><p><strong>NONMEM Equivalent:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">diag(nV,</span> <span class="pre">nCl)</span></code> is similar to NONMEM’s:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$OMEGA DIAG
0.04 ;nV
0.09 ;nCl
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">block(nV,</span> <span class="pre">nCl)</span></code> is similar to NONMEM’s:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$OMEGA BLOCK(2)
0.04 ;nV
0.02 0.09 ;nCl
</pre></div>
</div>
</li>
</ul>
<p><strong>Examples:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>ranef(diag(nV, nCl) = c(0.04, 0.09))  // Diagonal covariance: V and Cl vary independently

ranef(block(nV, nCl) = c(0.04, 0.02, 0.09))  // Full covariance: V and Cl are correlated

ranef(diag(nV) = c(0.04), diag(nCl) = c(0.09)) // Equivalent to the first example

ranef(block(nCl1, nCl2) = c(1, 0.5, 2), same(nCl3, nCl4)) //block + same
</pre></div>
</div>
<p><strong>Keywords:</strong> random effect, ranef, inter-individual variability, IIV, variance, covariance, omega, diag, block, same</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="mono reference internal" href="#nlme-fixef"><span class="std std-ref">fixef</span></a>, <a class="reference internal" href="#nlme-random-effects"><span class="std std-ref">Random Effects</span></a>, Variance, Covariance, Inter-Individual Variability</p>
</section>
<section id="fixed-effects">
<span id="nlme-fixed-effects"></span><h3>Fixed Effects<a class="headerlink" href="#fixed-effects" title="Link to this heading">¶</a></h3>
<p>Fixed effects represent the typical or population values of
parameters in the model. They are estimated from the data and are
assumed to be constant across all individuals.</p>
<p>* Represented by <code class="docutils literal notranslate"><span class="pre">fixef</span></code> * Usually defined with <code class="docutils literal notranslate"><span class="pre">tv</span></code> prefix</p>
<p><strong>Keywords:</strong> fixed effect, population parameter, typical value, theta, fixef</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-fixef"><span class="std std-ref">fixef</span></a>, <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="reference internal" href="#nlme-random-effects"><span class="std std-ref">Random Effects</span></a></p>
</section>
<section id="random-effects">
<span id="nlme-random-effects"></span><h3>Random Effects<a class="headerlink" href="#random-effects" title="Link to this heading">¶</a></h3>
<p>Random effects represent the variability in parameters
<em>between</em> individuals. They are assumed to be drawn from a distribution
(usually normal or log-normal) with a mean of zero and an estimated
variance-covariance matrix.</p>
<p>* Represented by <code class="docutils literal notranslate"><span class="pre">ranef</span></code> * Usually defined with <code class="docutils literal notranslate"><span class="pre">n</span></code> prefix</p>
<p><strong>Keywords:</strong> random effect, inter-individual variability, IIV, eta, ranef, variance, covariance</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-ranef"><span class="std std-ref">ranef</span></a>, <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="reference internal" href="#nlme-fixed-effects"><span class="std std-ref">Fixed Effects</span></a>, Variance, Covariance, Inter-Individual Variability</p>
</section>
<section id="log-normal-distribution">
<span id="nlme-log-normal-distribution"></span><h3>Log-Normal Distribution<a class="headerlink" href="#log-normal-distribution" title="Link to this heading">¶</a></h3>
<p>The log-normal distribution is commonly used for parameters that must be positive (e.g., clearance, volume). It’s implemented in <code class="docutils literal notranslate"><span class="pre">stparm</span></code> using the <code class="docutils literal notranslate"><span class="pre">exp()</span></code> function.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">tvParameter</span> <span class="pre">*</span> <span class="pre">exp(nParameter)</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">tvParameter</span></code>: The typical value (fixed effect).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">nParameter</span></code>: The random effect (normally distributed with mean
0).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exp()</span></code>: The exponential function. This ensures that
<code class="docutils literal notranslate"><span class="pre">parameter</span></code> is always positive, regardless of the value of
<code class="docutils literal notranslate"><span class="pre">nParameter</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Why Log-Normal?</strong> Many pharmacokinetic parameters (e.g., clearance,
volume) can only have positive values. The log-normal distribution
guarantees positivity.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>stparm(
  Cl = tvCl * exp(nCl)  // Clearance is log-normally distributed
)
</pre></div>
</div>
<p><strong>Keywords:</strong> log-normal, distribution, positive parameter, stparm, exp</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="reference internal" href="#nlme-fixed-effects"><span class="std std-ref">Fixed Effects</span></a>, <a class="reference internal" href="#nlme-random-effects"><span class="std std-ref">Random Effects</span></a>, <a class="reference internal" href="#nlme-normal-distribution"><span class="std std-ref">Normal Distribution</span></a></p>
</section>
<section id="normal-distribution">
<span id="nlme-normal-distribution"></span><h3>Normal Distribution<a class="headerlink" href="#normal-distribution" title="Link to this heading">¶</a></h3>
<p>The normal distribution can be used for parameters that can
take on both positive and negative values.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">tvParameter</span> <span class="pre">+</span> <span class="pre">nParameter</span></code></p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>stparm(
  Effect = tvEffect + nEffect  // Effect can be positive or negative
)
</pre></div>
</div>
<p><strong>Keywords:</strong> normal, distribution, stparm, additive</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="reference internal" href="#nlme-log-normal-distribution"><span class="std std-ref">Log-Normal Distribution</span></a></p>
</section>
<section id="bounds">
<span id="nlme-bounds"></span><h3>Bounds<a class="headerlink" href="#bounds" title="Link to this heading">¶</a></h3>
<p>Bounds (lower and upper limits) can be specified for fixed effects within the <code class="docutils literal notranslate"><span class="pre">fixef</span></code> statement. This constrains the parameter
values during estimation, preventing them from taking on unrealistic values.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">fixef(parameter</span> <span class="pre">=</span> <span class="pre">c([lower</span> <span class="pre">bound],[</span> <span class="pre">initial</span> <span class="pre">estimate],[</span> <span class="pre">upper</span> <span class="pre">bound]))</span></code></p></li>
<li><p>Any value could be skipped</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>fixef(
  tvCl = c(0, 5, 20)  // Cl must be between 0 and 20, with an initial estimate of 5
)
</pre></div>
</div>
<p><strong>Keywords:</strong> bounds, fixef, lower bound, upper bound, parameter constraints</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-fixef"><span class="std std-ref">fixef</span></a></p>
</section>
</section>
<section id="covariates">
<span id="nlme-covariates"></span><h2>Covariates<a class="headerlink" href="#covariates" title="Link to this heading">¶</a></h2>
<p>Covariates are variables that can influence the model’s
parameters or outcomes. They represent characteristics of the
individuals, their environment, or external influences. PML supports
continuous, categorical, and occasional covariates, any of which can be
time-varying.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To incorporate the effects of individual
characteristics, external factors, or time-dependent changes on the
model.</p></li>
<li><p><strong>Types of Covariates:</strong></p>
<ul>
<li><p><strong>Continuous:</strong> Take on a continuous range of numerical values
(e.g., weight, age, creatinine clearance).</p></li>
<li><p><strong>Categorical:</strong> Take on a limited number of discrete values
representing categories (e.g., sex, disease status, treatment
group).</p></li>
<li><p><strong>Occasional:</strong> Represent different occasions or periods <em>within</em>
an individual’s data (e.g., different treatment cycles). These are
inherently time-varying.</p></li>
</ul>
</li>
<li><p><strong>Declaration:</strong> Covariates <em>must</em> be declared using either the
<code class="docutils literal notranslate"><span class="pre">covariate</span></code>, <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>, or <code class="docutils literal notranslate"><span class="pre">interpolate</span></code> statement.</p></li>
<li><p><strong>Time-Varying Behavior:</strong> <em>Any</em> type of covariate (continuous,
categorical, or occasional) can be time-varying. The <code class="docutils literal notranslate"><span class="pre">covariate</span></code>,
<code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>, and <code class="docutils literal notranslate"><span class="pre">interpolate</span></code> statements control how the
covariate values are handled over time.</p></li>
<li><p><strong>Usage:</strong> Covariates can be used in:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">stparm</span></code> statements to model their effects on structural
parameters.</p></li>
<li><p>Expressions within the model (e.g., in <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statements or
likelihood calculations).</p></li>
</ul>
</li>
<li><p><strong>Data Mapping:</strong> Covariates are linked to columns in the input
dataset through <em>column mappings</em>. This is typically done in a
separate file or within the user interface of the modeling software
(e.g., Phoenix NLME). The correct syntax for mapping is, for example,
<code class="docutils literal notranslate"><span class="pre">covr(wt&lt;-&quot;wt&quot;)</span></code>.</p></li>
</ul>
<p><strong>Keywords:</strong> covariate, independent variable, predictor, time-varying, categorical, continuous, occasional, fcovariate, covariate, input, data mapping</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-covariate"><span class="std std-ref">covariate</span></a>, <a class="mono reference internal" href="#nlme-fcovariate"><span class="std std-ref">fcovariate</span></a>, <a class="mono reference internal" href="#nlme-interpolate"><span class="std std-ref">interpolate</span></a>, <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="reference internal" href="#nlme-continuous-covariates"><span class="std std-ref">Continuous Covariates</span></a>, <a class="reference internal" href="#nlme-categorical-covariates"><span class="std std-ref">Categorical Covariates</span></a>, <a class="reference internal" href="#nlme-occasion-covariates-and-iov"><span class="std std-ref">Occasional Covariates</span></a>, <a class="reference internal" href="#nlme-time-varying-covariates"><span class="std std-ref">Time-Varying Covariates</span></a>, <a class="reference internal" href="#nlme-data-mapping"><span class="std std-ref">Data Mapping</span></a></p>
<section id="covariate">
<span id="nlme-covariate"></span><h3>covariate<a class="headerlink" href="#covariate" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">covariate</span></code> statement declares a covariate and
specifies that its values should be extrapolated <em>backward</em> in time. The
most recent value of the covariate is used until a new value is
encountered.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">covariate(covariateName)</span></code> or
<code class="docutils literal notranslate"><span class="pre">covariate(covariateName())</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">covariateName</span></code>: The name of the covariate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">()</span></code>: Empty parentheses are <em>required</em> for categorical
covariates and <em>recommended</em> for occasional covariates (though
technically optional for occasion).</p></li>
</ul>
</li>
<li><p><strong>Backward Extrapolation:</strong> The value of the covariate at any given
time is the <em>most recent</em> value observed <em>before</em> that time. If no
value is given at time=0, the first available value is used.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>covariate(Weight)  // Declares &#39;Weight&#39; as a continuous covariate
covariate(Sex())    // Declares &#39;Sex&#39; as a categorical covariate
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> There is no direct equivalent in NONMEM. NONMEM’s default behavior for covariates is backward extrapolation, similar to PML’s <code class="docutils literal notranslate"><span class="pre">covariate</span></code>.</p>
<p><strong>Keywords:</strong> covariate, backward extrapolation, time-varying covariate</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="mono reference internal" href="#nlme-fcovariate"><span class="std std-ref">fcovariate</span></a>, <a class="mono reference internal" href="#nlme-interpolate"><span class="std std-ref">interpolate</span></a>, <a class="reference internal" href="#nlme-time-varying-covariates"><span class="std std-ref">Time-Varying Covariates</span></a>, <a class="reference internal" href="#nlme-categorical-covariates"><span class="std std-ref">Categorical Covariates</span></a>, <a class="reference internal" href="#nlme-occasion-covariates-and-iov"><span class="std std-ref">Occasional Covariates</span></a></p>
</section>
<section id="fcovariate">
<span id="nlme-fcovariate"></span><h3>fcovariate<a class="headerlink" href="#fcovariate" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code> statement declares a covariate and
specifies that its values should be extrapolated <em>forward</em> in time. The
current value is used until a new value is encountered. <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>
is generally preferred for occasion covariates.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">fcovariate(covariateName)</span></code> or
<code class="docutils literal notranslate"><span class="pre">fcovariate(covariateName())</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">covariateName</span></code>: The name of the covariate.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">()</span></code>: Empty parentheses are <em>required</em> for categorical
covariates and <em>recommended</em> (but technically optional) for
occasional covariates.</p></li>
</ul>
</li>
<li><p><strong>Forward Extrapolation:</strong> The value of the covariate at any given
time is the value observed <em>at</em> that time, and this value is carried
<em>forward</em> until a new value is encountered. The first available value
is also carried backward if no value is given at time=0.</p></li>
<li><p><strong>Occasion Covariates:</strong> <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code> is generally preferred for
<em>occasion covariates</em>.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>fcovariate(DoseRate)   // Declares &#39;DoseRate&#39; as a time-varying covariate
fcovariate(Occasion())  // Declares &#39;Occasion&#39; as an occasion covariate (recommended)
fcovariate(Occasion) // also valid, but less explicit
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> There’s no direct equivalent in NONMEM. You would typically handle forward extrapolation of occasion covariates implicitly
through the structure of your dataset and control stream.</p>
<p><strong>Keywords:</strong> fcovariate, forward extrapolation, time-varying covariate, occasion covariate</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="mono reference internal" href="#nlme-covariate"><span class="std std-ref">covariate</span></a>, <a class="mono reference internal" href="#nlme-interpolate"><span class="std std-ref">interpolate</span></a>, <a class="reference internal" href="#nlme-time-varying-covariates"><span class="std std-ref">Time-Varying Covariates</span></a>, <a class="reference internal" href="#nlme-occasion-covariates-and-iov"><span class="std std-ref">Occasional Covariates</span></a>, <a class="reference internal" href="#nlme-categorical-covariates"><span class="std std-ref">Categorical Covariates</span></a></p>
</section>
<section id="interpolate">
<span id="nlme-interpolate"></span><h3>interpolate<a class="headerlink" href="#interpolate" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">interpolate</span></code> statement declares a <em>continuous</em>
covariate whose values are linearly interpolated between the time points
at which it is set.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">interpolate(covariateName)</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">covariateName</span></code>: The name of the covariate.</p></li>
</ul>
</li>
<li><p><strong>Linear Interpolation:</strong> The value of the covariate varies linearly
between the time points at which it is set in time-based models.</p></li>
<li><p><strong>Extrapolation:</strong> If no covariate value is given, the latest value
is carried forward. If no value is given at time=0, the first
available value is used.</p></li>
<li><p><strong>Continuous Covariates Only:</strong> <code class="docutils literal notranslate"><span class="pre">interpolate</span></code> can <em>only</em> be used
with <em>continuous</em> covariates.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>interpolate(InfusionRate)
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> There is no direct equivalent in NONMEM. Linear interpolation of covariates is not a built-in feature. You would
typically pre-process your data to create interpolated values if needed.</p>
<p><strong>Keywords:</strong> interpolate, covariate, linear interpolation, time-varying covariate, continuous covariate</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="mono reference internal" href="#nlme-covariate"><span class="std std-ref">covariate</span></a>, <a class="mono reference internal" href="#nlme-fcovariate"><span class="std std-ref">fcovariate</span></a>, <a class="reference internal" href="#nlme-time-varying-covariates"><span class="std std-ref">Time-Varying Covariates</span></a>, <a class="reference internal" href="#nlme-continuous-covariates"><span class="std std-ref">Continuous Covariates</span></a></p>
</section>
<section id="continuous-covariates">
<span id="nlme-continuous-covariates"></span><h3>Continuous Covariates<a class="headerlink" href="#continuous-covariates" title="Link to this heading">¶</a></h3>
<p>Continuous covariates take on a continuous range of
numerical values. They can be time-varying or constant within an
individual.</p>
<ul class="simple">
<li><p><strong>Examples:</strong> Weight, age, creatinine clearance, body surface area.</p></li>
<li><p><strong>Declaration:</strong> Declared using <code class="docutils literal notranslate"><span class="pre">covariate</span></code>, <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>, or
<code class="docutils literal notranslate"><span class="pre">interpolate</span></code>.</p></li>
<li><p><strong>Usage:</strong> Used directly in mathematical expressions within
<code class="docutils literal notranslate"><span class="pre">stparm</span></code> statements or other model equations.</p></li>
<li><p><strong>Mapping:</strong> <code class="docutils literal notranslate"><span class="pre">covr(Wt&lt;-&quot;Wt&quot;)</span></code></p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>fcovariate(Weight)  // Weight as a time-varying covariate

stparm(
  Cl = tvCl * (Weight / 70)^0.75 * exp(nCl)  // Allometric scaling of clearance
)
</pre></div>
</div>
<p><strong>Keywords:</strong> continuous covariate, covariate, numerical, time-varying</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="mono reference internal" href="#nlme-covariate"><span class="std std-ref">covariate</span></a>, <a class="mono reference internal" href="#nlme-fcovariate"><span class="std std-ref">fcovariate</span></a>, <a class="mono reference internal" href="#nlme-interpolate"><span class="std std-ref">interpolate</span></a>, <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="reference internal" href="#nlme-data-mapping"><span class="std std-ref">Data Mapping</span></a></p>
</section>
<section id="categorical-covariates">
<span id="nlme-categorical-covariates"></span><h3>Categorical Covariates<a class="headerlink" href="#categorical-covariates" title="Link to this heading">¶</a></h3>
<p>Categorical covariates take on a limited number of discrete
values representing categories. PML requires you to define the mapping
between the data values and category names in the <em>column definition
file</em>.</p>
<ul class="simple">
<li><p><strong>Examples:</strong> Sex (Male/Female), Disease Status (Normal/Mild/Severe),
Treatment Group (Placebo/Active).</p></li>
<li><p><strong>Declaration:</strong> Declared using <code class="docutils literal notranslate"><span class="pre">covariate(CovariateName())</span></code> or
<code class="docutils literal notranslate"><span class="pre">fcovariate(CovariateName())</span></code>. The empty parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code> are
<em>required</em>.</p></li>
<li><p><strong>Mapping (Column Definition File):</strong> You <em>must</em> map the covariate
and its categories in the column definition file (or equivalent
interface in your software).</p>
<ul>
<li><p><strong>With Labels:</strong> If your data file already contains meaningful
category labels (e.g., “Male”, “Female”), map them directly. The
general NONMEM-style syntax is:
<code class="docutils literal notranslate"><span class="pre">covr(Sex</span> <span class="pre">&lt;-</span> <span class="pre">&quot;Sex&quot;(&quot;Male&quot;</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">&quot;Female&quot;</span> <span class="pre">=</span> <span class="pre">1))</span>&#160; <span class="pre">//</span> <span class="pre">Example</span></code> This
maps the “Sex” column in the data to a covariate named <code class="docutils literal notranslate"><span class="pre">Sex</span></code> in
the model, with “Male” coded as 0 and “Female” as 1. The first
category is used as a reference category.</p></li>
<li><p><strong>Without Labels:</strong> If your data file uses numeric codes (e.g., 0,
1) without explicit labels, you can define the labels during
mapping using empty parentheses:
<code class="docutils literal notranslate"><span class="pre">covr(Sex</span> <span class="pre">&lt;-</span> <span class="pre">&quot;Sex&quot;())</span>&#160; <span class="pre">//</span> <span class="pre">Example</span></code> In that case the first unique
value will be used as a reference.</p></li>
</ul>
</li>
<li><p><strong>Usage in stparm:</strong> You typically use logical expressions
<code class="docutils literal notranslate"><span class="pre">(CovariateName</span> <span class="pre">==</span> <span class="pre">value)</span></code> within <code class="docutils literal notranslate"><span class="pre">stparm</span></code> statements to model
the effects of different categories. This creates implicit “dummy
variables.” The first category encountered in the data is treated as
the <em>reference category</em>, and fixed effects for other categories
represent differences from the reference. Use the ternary operator
(<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>) for more complex conditional logic.</p></li>
</ul>
<p><strong>Example (PML code):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
  fcovariate(Sex())  // Declare Sex as a categorical covariate

  stparm(
    Cl = tvCl * exp(dClSex * (Sex == 1) + nCl)  // Effect of Sex on Cl
  )

  fixef(
    tvCl   = c(, 10, ),
    dClSex = c(, 0, )  // Fixed effect for Sex=1 (relative to Sex=0)
  )

  ranef(diag(nCl) = c(0.25))

  // ... rest of the model ...
}
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> The PML code above is similar to the following in
NONMEM (using abbreviated code):</p>
<div class="highlight-nonmem notranslate"><div class="highlight"><pre><span></span>$INPUT ... SEX ...
$SUBROUTINES ...
$PK
  TVCL = THETA(1)
  DCLSEX = THETA(2)
  CL = TVCL * EXP(DCLSEX*(SEX.EQ.1) + ETA(1))
$THETA
 (0, 10) ; TVCL
 (0)      ; DCLSEX
$OMEGA
 0.25 ; ETA(1) variance (IIV on CL)
</pre></div>
</div>
<p><strong>Keywords:</strong> categorical covariate, covariate, discrete, categories, dummy variable, indicator variable, time-varying, data mapping</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="mono reference internal" href="#nlme-covariate"><span class="std std-ref">covariate</span></a>, <a class="mono reference internal" href="#nlme-fcovariate"><span class="std std-ref">fcovariate</span></a>, <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="reference internal" href="#nlme-fixed-effects"><span class="std std-ref">Fixed Effects</span></a>, <a class="reference internal" href="#nlme-data-mapping"><span class="std std-ref">Data Mapping</span></a>, Dummy Variables, <a class="reference internal" href="#nlme-if-and-ternary-operator"><span class="std std-ref">if and Ternary Operator</span></a></p>
</section>
<section id="occasion-covariates-and-inter-occasion-variability-iov">
<span id="nlme-occasion-covariates-and-iov"></span><h3>Occasion Covariates and Inter-Occasion Variability (IOV)<a class="headerlink" href="#occasion-covariates-and-inter-occasion-variability-iov" title="Link to this heading">¶</a></h3>
<p>Occasion covariates represent distinct periods in a
subject’s data (e.g., treatment cycles). Their primary use is to model
<strong>Inter-Occasion Variability (IOV)</strong>, which is the random, unpredictable
variability <em>within a single subject</em> from one occasion to the next.
This is modeled using <strong>random effects</strong>, not fixed effects.</p>
<ul class="simple">
<li><p><strong>Concept:</strong> While Inter-Individual Variability (IIV) describes why
Subject A’s average parameter value is different from Subject B’s,
IOV describes why Subject A’s parameter value during Occasion 1 is
different from their own value during Occasion 2.</p></li>
<li><p><strong>Declaration:</strong> Always declare the occasion variable, preferably
with <code class="docutils literal notranslate"><span class="pre">fcovariate(Occasion())</span></code>. The parentheses <code class="docutils literal notranslate"><span class="pre">()</span></code> are
recommended for clarity.</p></li>
</ul>
<p><strong>Correct Implementation: Modeling IOV with Random Effects</strong></p>
<p>This is the standard and pharmacokinetically correct approach. It
assumes that a subject’s parameter value for a specific occasion is a
random deviation from their overall mean parameter value.</p>
<ul class="simple">
<li><p><strong>PML Syntax:</strong> You create a separate random effect (<code class="docutils literal notranslate"><span class="pre">eta</span></code>) for
each occasion level and add it to the structural parameter
expression.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">stparm(Param</span> <span class="pre">=</span> <span class="pre">tvParam</span> <span class="pre">*</span> <span class="pre">exp(</span> <span class="pre">nParam</span> <span class="pre">+</span> <span class="pre">nParamOcc1*(Occasion==1)</span> <span class="pre">+</span> <span class="pre">nParamOcc2*(Occasion==2)</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">))</span></code></p></li>
</ul>
</li>
<li><p>The term <code class="docutils literal notranslate"><span class="pre">nParam</span></code> represents the subject’s IIV (their deviation
from the population typical value <code class="docutils literal notranslate"><span class="pre">tvParam</span></code>).</p></li>
<li><p>The terms <code class="docutils literal notranslate"><span class="pre">nParamOcc1</span></code>, <code class="docutils literal notranslate"><span class="pre">nParamOcc2</span></code>, etc., represent the IOV
(the deviation for that specific occasion from the subject’s mean).</p></li>
</ul>
<p><strong>Example (IOV on Clearance):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
  fcovariate(Occasion()) // Assume Occasion has levels 1, 2, 3

  // Cl includes a random effect for IIV (nCl) and separate random effects for IOV on each occasion
  stparm(Cl = tvCl * exp( nCl + nCl_Occ1*(Occasion==1) + nCl_Occ2*(Occasion==2) + nCl_Occ3*(Occasion==3) ))

  fixef(tvCl = c(, 1, ))
  ranef(diag(nCl) = c(1)) // IIV variance on Cl

  // Define the IOV variances. &#39;same()&#39; is often used to assume variability is equal across occasions.
  ranef(diag(nCl_Occ1) = c(1), same(nCl_Occ2), same(nCl_Occ3))
  ...
}
</pre></div>
</div>
<p><strong>Incorrect Implementation: Modeling Occasions with Fixed Effects</strong></p>
<p>It is also possible to model an occasion as a fixed effect, but this
answers a different scientific question and is generally not what is
meant by an “occasion effect.” A fixed effect tests whether the
<em>population average</em> parameter is systematically different on one
occasion versus another (e.g., “Is clearance for <em>all subjects</em> 20%
lower on Occasion 2?”). This is a cohort effect, not within-subject
variability.</p>
<p><strong>Example of an (often incorrect) fixed-effect model:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>// This model tests if the POPULATION mean Cl is different on Occasion 2 vs Occasion 1
stparm(Cl = tvCl * exp( dCldOcc2*(Occasion==2) ) * exp(nCl))
fixef(dCldOcc2 = c(, 0, )) // Fixed effect for Occasion 2
</pre></div>
</div>
<p><strong>pyDarwin Automation Note:</strong> When searching for IOV on a parameter, the
token should provide two options: one with only the base IIV random
effect, and one that adds the IOV random effects. The token must swap
out both the <code class="docutils literal notranslate"><span class="pre">stparm</span></code> expression and the corresponding <code class="docutils literal notranslate"><span class="pre">ranef</span></code>
block.</p>
<p><strong>Correct Token Structure for IOV on Clearance (_nCl):</strong></p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;_nCl&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">        </span><span class="s2">&quot;* exp(nCl)&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;ranef(diag(nCl) = c(1))&quot;</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">        </span><span class="s2">&quot;* exp(nCl + (Occasion==1)*nClOccasionx1 + (Occasion==2)*nClOccasionx2)&quot;</span><span class="p">,</span>
<span class="w">        </span><span class="s2">&quot;ranef(diag(nCl) = c(1))\\n\\tranef(diag(nClOccasionx1) = c(1), same(nClOccasionx2))&quot;</span>
<span class="w">    </span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>This correctly links the structural model change to the necessary change
in the random effects structure.</p>
<p><strong>Keywords:</strong> occasion covariate, IOV, inter-occasion variability, fcovariate, random effects, fixed effects, within-subject variability</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-fcovariate"><span class="std std-ref">fcovariate</span></a>, <a class="reference internal" href="#nlme-random-effects"><span class="std std-ref">Random Effects</span></a>, <a class="mono reference internal" href="#nlme-ranef"><span class="std std-ref">ranef</span></a>, <a class="reference internal" href="#nlme-fixed-effects"><span class="std std-ref">Fixed Effects</span></a>, <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, Inter-Individual Variability</p>
</section>
<section id="time-varying-covariates">
<span id="nlme-time-varying-covariates"></span><h3>Time-Varying Covariates<a class="headerlink" href="#time-varying-covariates" title="Link to this heading">¶</a></h3>
<p>Time-varying covariates are covariates whose values can
change <em>within</em> an individual over time. They are essential for modeling
dynamic processes and external influences that vary during the
observation period. <em>Any</em> type of covariate (continuous, categorical, or
occasional) can be time-varying.</p>
<ul class="simple">
<li><p><strong>Declaration:</strong> Declared using <code class="docutils literal notranslate"><span class="pre">covariate</span></code>, <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>, or
<code class="docutils literal notranslate"><span class="pre">interpolate</span></code>. <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code> is generally preferred for most
time-varying covariates, especially for categorical and occasion
covariates.</p></li>
<li><p><strong>Data:</strong> The input data must include multiple records per
individual, with different time points and corresponding covariate
values.</p></li>
<li><p><strong>Extrapolation:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">covariate</span></code>: Backward extrapolation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>: Forward extrapolation (and backward extrapolation
for the first value).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">interpolate</span></code>: Linear interpolation between defined points
(continuous covariates only), forward extrapolation after the last
defined point.</p></li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>fcovariate(DoseRate)   // DoseRate can change over time

stparm(
  Cl = tvCl * exp(dClDoseRate * DoseRate + nCl)  // Clearance depends on DoseRate
)

// ... rest of the model ...
</pre></div>
</div>
<p><strong>Keywords:</strong> time-varying covariate, covariate, fcovariate, covariate, changing covariate, dynamic covariate</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="mono reference internal" href="#nlme-covariate"><span class="std std-ref">covariate</span></a>, <a class="mono reference internal" href="#nlme-fcovariate"><span class="std std-ref">fcovariate</span></a>, <a class="mono reference internal" href="#nlme-interpolate"><span class="std std-ref">interpolate</span></a>, <a class="reference internal" href="#nlme-continuous-covariates"><span class="std std-ref">Continuous Covariates</span></a>, <a class="reference internal" href="#nlme-categorical-covariates"><span class="std std-ref">Categorical Covariates</span></a>, <a class="reference internal" href="#nlme-occasion-covariates-and-iov"><span class="std std-ref">Occasional Covariates</span></a></p>
</section>
</section>
<section id="structural-model-definition">
<span id="nlme-structural-model-definition"></span><h2>Structural Model Definition<a class="headerlink" href="#structural-model-definition" title="Link to this heading">¶</a></h2>
<section id="deriv">
<span id="nlme-deriv"></span><h3>deriv<a class="headerlink" href="#deriv" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statement defines an ordinary differential
equation (ODE) in the model. This is used to describe how the amount of
drug (or other quantities) in a compartment changes over time. Models
with <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statements are inherently time-based.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To define the rate of change of a state variable
(typically a compartment amount).</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">deriv(variable</span> <span class="pre">=</span> <span class="pre">expression)</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">variable</span></code>: The name of the state variable being differentiated
(e.g., <code class="docutils literal notranslate"><span class="pre">A1</span></code>, <code class="docutils literal notranslate"><span class="pre">Aa</span></code>, <code class="docutils literal notranslate"><span class="pre">CumHaz</span></code>). This variable is often called
an “integrator variable.”</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expression</span></code>: An expression defining the rate of change of the
variable. This can involve parameters, covariates, other
variables, and mathematical functions.</p></li>
</ul>
</li>
<li><p><strong>Time-Based Models:</strong> If a model contains <em>any</em> <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statement,
it is considered a <em>time-based model</em>, and the built-in variable
<code class="docutils literal notranslate"><span class="pre">t</span></code> (representing time) is automatically available.</p></li>
<li><p><strong>State variable modification:</strong> Variables on the left side of deriv
statements can be modified when the model is stopped</p></li>
<li><p><strong>Multiple deriv statements:</strong> A model will typically have
multiple <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statements, one for each compartment or state
variable being modeled.</p></li>
<li><p><strong>Right-hand-side Discontinuity:</strong> The use of <code class="docutils literal notranslate"><span class="pre">t</span></code> variable on the
right-hand-side is discouraged.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>deriv(Aa = -Ka * Aa)      // Rate of change of amount in absorption compartment Aa
deriv(A1 = Ka*Aa -Cl * C)       // Rate of change of amount in compartment A1
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> The PML code above is similar to the following
NONMEM code:</p>
<div class="highlight-nonmem notranslate"><div class="highlight"><pre><span></span>$DES
DADT(1) = -KA*A(1)
DADT(2) = KA*A(1) -CL*A(2)/V
</pre></div>
</div>
<p><strong>Keywords:</strong> deriv, differential equation, ODE, integrator, state variable, time-based model, dynamic model</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a>, <a class="mono reference internal" href="#nlme-dosepoint"><span class="std std-ref">dosepoint</span></a>, <a class="mono reference internal" href="#nlme-urinecpt"><span class="std std-ref">urinecpt</span></a></p>
</section>
<section id="compartment-models">
<span id="nlme-compartment-models"></span><h3>Compartment Models<a class="headerlink" href="#compartment-models" title="Link to this heading">¶</a></h3>
<p>Compartment models are a common type of pharmacokinetic
model where the body is represented as a series of interconnected
compartments. Drug movement between compartments is described by
differential equations.</p>
<ul class="simple">
<li><p><strong>Compartments:</strong> Represent theoretical spaces where the drug distributes (e.g., central compartment, peripheral compartment, absorption compartment).</p></li>
<li><p><strong>Differential Equations:</strong> Describe the rate of change of the amount of drug in each compartment.</p></li>
<li><p><strong>Parameters:</strong> Define the rates of transfer between compartments and elimination from the body (e.g., clearance, volume, rate constants).</p></li>
<li><p><strong>Implementation in PML:</strong> Compartment models can be implemented using:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">deriv</span></code> statements (for custom models or when flexibility is
needed).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cfMicro</span></code> or <code class="docutils literal notranslate"><span class="pre">cfMacro</span></code> statements (for standard 1, 2, or
3-compartment models).</p></li>
</ul>
</li>
</ul>
<p><strong>Keywords:</strong> compartment model, compartment, differential equation, PK model, ADVAN</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-deriv"><span class="std std-ref">deriv</span></a>, <a class="mono reference internal" href="#nlme-cfmicro"><span class="std std-ref">cfMicro</span></a>, <a class="mono reference internal" href="#nlme-cfmacro"><span class="std std-ref">cfMacro</span></a>, Pharmacokinetics</p>
</section>
<section id="cfmicro">
<span id="nlme-cfmicro"></span><h3>cfMicro<a class="headerlink" href="#cfmicro" title="Link to this heading">¶</a></h3>
<p>Provides an efficient <strong>closed-form (analytical) solution</strong>
for standard compartment models using micro-constants. This statement is
<strong>not compatible</strong> with time-varying parameters and must be replaced by
<code class="docutils literal notranslate"><span class="pre">deriv</span></code> statements in such cases.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To define a standard one-, two-, or three-compartment
model without explicitly writing out the differential equations,
which can improve performance.</p></li>
<li><p><strong>Parameterization:</strong> Uses <em>micro-constants</em> (e.g., <code class="docutils literal notranslate"><span class="pre">Ke</span></code>, <code class="docutils literal notranslate"><span class="pre">K12</span></code>,
<code class="docutils literal notranslate"><span class="pre">K21</span></code>).</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">cfMicro(A,</span> <span class="pre">Ke,</span> <span class="pre">[K12,</span> <span class="pre">K21],</span> <span class="pre">[K13,</span> <span class="pre">K31],</span> <span class="pre">[first</span> <span class="pre">=</span> <span class="pre">(Aa</span> <span class="pre">=</span> <span class="pre">Ka)])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: The amount in the central compartment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Ke</span></code>: The elimination rate constant.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">K12</span></code>, <code class="docutils literal notranslate"><span class="pre">K21</span></code>: (Optional) Transfer rate constants for a
two-compartment model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">K13</span></code>, <code class="docutils literal notranslate"><span class="pre">K31</span></code>: (Optional) Transfer rate constants for a
three-compartment model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">first</span> <span class="pre">=</span> <span class="pre">(Aa</span> <span class="pre">=</span> <span class="pre">Ka)</span></code>: (Optional) Specifies first-order absorption
from a depot compartment <code class="docutils literal notranslate"><span class="pre">Aa</span></code> with absorption rate constant
<code class="docutils literal notranslate"><span class="pre">Ka</span></code>.</p></li>
</ul>
</li>
</ul>
<hr class="docutils" />
<p><strong>CRITICAL LIMITATION: Time-Varying Parameters</strong></p>
<p>The <code class="docutils literal notranslate"><span class="pre">cfMicro</span></code> statement uses a <strong>piecewise closed-form (analytical)
solution</strong>. The fundamental assumption is that model parameters (like
<code class="docutils literal notranslate"><span class="pre">Cl</span></code>, <code class="docutils literal notranslate"><span class="pre">V</span></code>, <code class="docutils literal notranslate"><span class="pre">K12</span></code>, etc.) are <strong>constant between time-based events</strong>
(such as doses or changes in covariate values). When an event occurs,
the system re-evaluates the parameters and applies the closed-form
solution for the next interval.</p>
<p>This means <code class="docutils literal notranslate"><span class="pre">cfMicro</span></code> <strong>can correctly handle</strong> structural parameters
that depend on time-varying covariates declared with <code class="docutils literal notranslate"><span class="pre">covariate</span></code> or
<code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>, as these values change at discrete time points.</p>
<p>For example, a model with <code class="docutils literal notranslate"><span class="pre">stparm(Cl</span> <span class="pre">=</span> <span class="pre">tvCl</span> <span class="pre">*</span> <span class="pre">(CRCL/100)</span> <span class="pre">*</span> <span class="pre">exp(nCl))</span></code>
and <code class="docutils literal notranslate"><span class="pre">covariate(CRCL)</span></code> will work correctly with the following data, as
<code class="docutils literal notranslate"><span class="pre">Cl</span></code> is constant between t=0, t=2, and t=4:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>ID</p></th>
<th class="head"><p>TIME</p></th>
<th class="head"><p>AMT</p></th>
<th class="head"><p>Cobs</p></th>
<th class="head"><p>CRCL</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>100</p></td>
<td><p>0</p></td>
<td><p>70</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>2</p></td>
<td><p>.</p></td>
<td><p>80</p></td>
<td><p>70</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>4</p></td>
<td><p>.</p></td>
<td><p>70</p></td>
<td><p>60</p></td>
</tr>
</tbody>
</table>
<p>However, this piecewise assumption is violated if a structural parameter
changes <strong>continuously</strong> over time. This happens in two main scenarios:</p>
<ol class="arabic simple">
<li><p>A structural parameter depends on a covariate declared with
<code class="docutils literal notranslate"><span class="pre">interpolate()</span></code>.</p></li>
<li><p>A structural parameter’s definition explicitly includes the time
variable <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p></li>
</ol>
<ul class="simple">
<li><p><strong>CONSEQUENCE:</strong> Using <code class="docutils literal notranslate"><span class="pre">cfMicro</span></code> with continuously time-varying
parameters will produce <strong>incorrect results</strong> without generating a
syntax error.</p></li>
<li><p><strong>REQUIRED ACTION:</strong> If any model parameter changes continuously with
time (due to <code class="docutils literal notranslate"><span class="pre">interpolate()</span></code> or the use of <code class="docutils literal notranslate"><span class="pre">t</span></code>), you <strong>MUST</strong> use
<code class="docutils literal notranslate"><span class="pre">deriv</span></code> statements to define the model structure. This forces the
use of a numerical ODE solver that can correctly handle the dynamic
parameters.</p></li>
<li><p><strong>Stricter Rules for cfMacro and cfMacro1</strong>: These are pure
closed-form solutions and are more restrictive. They require
structural parameters to be constant for the entire observation
interval and do not support time-varying covariates of any kind.</p></li>
</ul>
<p><strong>Example of an INVALID model (due to interpolate):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
    interpolate(scr) // Makes scr a CONTINUOUSLY time-varying covariate
    stparm(Cl = tvCl + dCldscr * scr) // Cl is now continuously time-varying
    cfMicro(A1, Cl / V) // INVALID: cfMicro cannot handle a continuously time-varying Cl
    ...
}
</pre></div>
</div>
<p><strong>Example of the CORRECT equivalent model:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
    interpolate(scr) // Continuously time-varying covariate
    stparm(Cl = tvCl + dCldscr * scr) // Cl is continuously time-varying
    deriv(A1 = - (Cl/V) * A1) // CORRECT: Must use deriv statement
    ...
}
</pre></div>
</div>
<hr class="docutils" />
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When designing a model search in pyDarwin, if <strong>any</strong> candidate model in your search space includes a time-varying covariate
effect on a structural parameter, <strong>all</strong> structural model options must be written using <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statements. Do not mix <code class="docutils literal notranslate"><span class="pre">cfMicro</span></code> and
<code class="docutils literal notranslate"><span class="pre">deriv</span></code> based structural models in the same search if time-varying covariates are involved, as it would be an invalid comparison.</p>
</div>
<hr class="docutils" />
<p><strong>Keywords:</strong> cfMicro, closed-form solution, compartment model, micro-constants, <code class="docutils literal notranslate"><span class="pre">deriv</span></code>, time-varying covariate, ODE solver</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-deriv"><span class="std std-ref">deriv</span></a>, <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a>, <a class="mono reference internal" href="#nlme-covariate"><span class="std std-ref">covariate</span></a>, <a class="mono reference internal" href="#nlme-interpolate"><span class="std std-ref">interpolate</span></a>, <a class="mono reference internal" href="#nlme-fcovariate"><span class="std std-ref">fcovariate</span></a>, <a class="reference internal" href="#nlme-time-varying-covariates"><span class="std std-ref">Time-Varying Covariates</span></a></p>
</section>
<section id="cfmacro-and-cfmacro1">
<span id="nlme-cfmacro"></span><h3>cfMacro and cfMacro1<a class="headerlink" href="#cfmacro-and-cfmacro1" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">cfMacro</span></code> and <code class="docutils literal notranslate"><span class="pre">cfMacro1</span></code> statements provide closed-form solutions for standard compartment models, parameterized
using <em>macro-constants</em> (coefficients and exponents of exponential terms). <code class="docutils literal notranslate"><span class="pre">cfMacro</span></code> offers more options, including a stripping dose.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To define a standard compartment model without explicitly writing out the differential equations, using a macro-constant parameterization.</p></li>
<li><p><strong>cfMacro Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">cfMacro(A,</span> <span class="pre">C,</span> <span class="pre">DoseVar,</span> <span class="pre">A,</span> <span class="pre">Alpha,</span> <span class="pre">[B,</span> <span class="pre">Beta],</span> <span class="pre">[C,</span> <span class="pre">Gamma],</span> <span class="pre">[strip=StripVar],</span> <span class="pre">[first=(Aa=Ka)])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: The amount in the central compartment (cannot be referred to elsewhere in the model).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code>: The <em>concentration</em> variable in the model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DoseVar</span></code>: A variable to record the initial bolus dose (needed for <code class="docutils literal notranslate"><span class="pre">idosevar</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">Alpha</span></code>: Macro-constants for the first exponential term.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">Beta</span></code>: (Optional) Macro-constants for the second exponential term (two-compartment model).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">C</span></code>, <code class="docutils literal notranslate"><span class="pre">Gamma</span></code>: (Optional) Macro-constants for the third exponential term (three-compartment model).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">strip=StripVar</span></code>: (Optional) Specifies a covariate (<code class="docutils literal notranslate"><span class="pre">StripVar</span></code>) to provide a “stripping dose” for simulations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">first</span> <span class="pre">=</span> <span class="pre">(Aa</span> <span class="pre">=</span> <span class="pre">Ka)</span></code>: (Optional) Specifies the first order absorption</p></li>
</ul>
</li>
<li><p><strong>cfMacro1 Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">cfMacro1(A,</span> <span class="pre">Alpha,</span> <span class="pre">[B,</span> <span class="pre">Beta],</span> <span class="pre">[C,</span> <span class="pre">Gamma],</span> <span class="pre">[first=(Aa=Ka)])</span></code></p>
<ul>
<li><p>Simplified version of <code class="docutils literal notranslate"><span class="pre">cfMacro</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: Amount in the central compartment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">Beta</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code>, <code class="docutils literal notranslate"><span class="pre">Gamma</span></code>: Macro-constants. The response to bolus dose is predefined</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">first</span> <span class="pre">=</span> <span class="pre">(Aa</span> <span class="pre">=</span> <span class="pre">Ka)</span></code>: (Optional) Specifies the first order absorption</p></li>
</ul>
</li>
<li><p><strong>Stripping Dose:</strong> The <code class="docutils literal notranslate"><span class="pre">strip</span></code> option in <code class="docutils literal notranslate"><span class="pre">cfMacro</span></code> allows you to
specify a covariate that provides a “stripping dose” value. This is
used in simulations to represent the initial dose used when the model
was originally fit.</p></li>
</ul>
<p><strong>Example (cfMacro with two compartments and stripping dose):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>cfMacro(A1, C1, A1Dose, A, Alpha, B, Beta, strip=A1Strip)
dosepoint(A1, idosevar = A1Dose)
covariate(A1Strip)
</pre></div>
</div>
<p><strong>Example (cfMacro1 with one compartment):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>cfMacro1(A, Alpha)
</pre></div>
</div>
<p><strong>Keywords:</strong> cfMacro, cfMacro1, closed-form solution, compartment model, macro-constants, A, Alpha, B, Beta, C, Gamma, stripping dose</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a>, <a class="mono reference internal" href="#nlme-deriv"><span class="std std-ref">deriv</span></a>, <a class="mono reference internal" href="#nlme-cfmicro"><span class="std std-ref">cfMicro</span></a>, Pharmacokinetics</p>
</section>
<section id="micro-constants-vs-macro-constants">
<span id="title-micro-constants-vs-macro-constants"></span><h3>Micro-Constants vs. Macro-Constants<a class="headerlink" href="#micro-constants-vs-macro-constants" title="Link to this heading">¶</a></h3>
<p>Compartment models can be parameterized using either
micro-constants (rate constants) or macro-constants (coefficients and
exponents of exponential terms). <code class="docutils literal notranslate"><span class="pre">cfMicro</span></code> uses micro-constants, while
<code class="docutils literal notranslate"><span class="pre">cfMacro</span></code> and <code class="docutils literal notranslate"><span class="pre">cfMacro1</span></code> use macro-constants.</p>
<ul class="simple">
<li><p><strong>Micro-Constants:</strong></p>
<ul>
<li><p>Rate constants that describe the transfer of drug between
compartments and elimination from the body (e.g., <code class="docutils literal notranslate"><span class="pre">Ke</span></code>, <code class="docutils literal notranslate"><span class="pre">K12</span></code>,
<code class="docutils literal notranslate"><span class="pre">K21</span></code>).</p></li>
<li><p>More directly related to the underlying physiological processes.</p></li>
<li><p>Used with <code class="docutils literal notranslate"><span class="pre">cfMicro</span></code> and <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statements.</p></li>
</ul>
</li>
<li><p><strong>Macro-Constants:</strong></p>
<ul>
<li><p>Coefficients and exponents of exponential terms in the closed-form
solution (e.g., <code class="docutils literal notranslate"><span class="pre">A</span></code>, <code class="docutils literal notranslate"><span class="pre">Alpha</span></code>, <code class="docutils literal notranslate"><span class="pre">B</span></code>, <code class="docutils literal notranslate"><span class="pre">Beta</span></code>, <code class="docutils literal notranslate"><span class="pre">C</span></code>,
<code class="docutils literal notranslate"><span class="pre">Gamma</span></code>).</p></li>
<li><p>Less intuitive from a physiological perspective.</p></li>
<li><p>Used with <code class="docutils literal notranslate"><span class="pre">cfMacro</span></code> and <code class="docutils literal notranslate"><span class="pre">cfMacro1</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Conversion:</strong> It’s possible to convert between micro-constants and
macro-constants, but the equations can be complex, especially for
models with more than one compartment.</p></li>
</ul>
<p><strong>Keywords:</strong> micro-constants, macro-constants, Ke, K12, K21, A, Alpha, B, Beta, C, Gamma, parameterization, cfMicro, cfMacro</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-cfmicro"><span class="std std-ref">cfMicro</span></a>, <a class="mono reference internal" href="#nlme-cfmacro"><span class="std std-ref">cfMacro</span></a>, <a class="mono reference internal" href="#nlme-cfmacro"><span class="std std-ref">cfMacro1</span></a>, <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a>, Pharmacokinetics</p>
</section>
<section id="dosepoint">
<span id="nlme-dosepoint"></span><h3>dosepoint<a class="headerlink" href="#dosepoint" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statement specifies a compartment that can receive doses (either bolus or infusion). It also allows for options
like lag time, infusion duration/rate, bioavailability, and actions performed before/after dosing.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To define where doses are administered in the model.</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">dosepoint(compartmentName</span> <span class="pre">[,</span> <span class="pre">tlag</span> <span class="pre">=</span> <span class="pre">expr][,</span> <span class="pre">duration</span> <span class="pre">=</span> <span class="pre">expr][,</span> <span class="pre">rate</span> <span class="pre">=</span> <span class="pre">expr][,</span> <span class="pre">bioavail</span> <span class="pre">=</span> <span class="pre">expr][,</span> <span class="pre">dobefore</span> <span class="pre">=</span> <span class="pre">sequenceStmt][,</span> <span class="pre">doafter</span> <span class="pre">=</span> <span class="pre">sequenceStmt][,</span> <span class="pre">split][,</span> <span class="pre">idosevar</span> <span class="pre">=</span> <span class="pre">variableName][,</span> <span class="pre">infdosevar</span> <span class="pre">=</span> <span class="pre">variableName][,</span> <span class="pre">infratevar</span> <span class="pre">=</span> <span class="pre">variableName])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">compartmentName</span></code>: The name of the compartment receiving the dose.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tlag</span> <span class="pre">=</span> <span class="pre">expr</span></code>: (Optional) Time delay before dose delivery.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">duration</span> <span class="pre">=</span> <span class="pre">expr</span></code>: (Optional) Duration of a zero-order infusion.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rate</span> <span class="pre">=</span> <span class="pre">expr</span></code>: (Optional) Rate of a zero-order infusion. Cannot be used with <code class="docutils literal notranslate"><span class="pre">duration</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bioavail</span> <span class="pre">=</span> <span class="pre">expr</span></code>: (Optional) Bioavailability fraction (0 to 1).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dobefore</span> <span class="pre">=</span> <span class="pre">sequenceStmt</span></code>: (Optional) <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block executed <em>before</em> dose delivery.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">doafter</span> <span class="pre">=</span> <span class="pre">sequenceStmt</span></code>: (Optional) <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block executed <em>after</em> dose delivery (or infusion completion).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">split</span></code>: (Optional, rarely used) For UI compatibility.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">idosevar</span> <span class="pre">=</span> <span class="pre">variableName</span></code>: (Optional) Captures the value of the <em>first bolus dose</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">infdosevar</span> <span class="pre">=</span> <span class="pre">variableName</span></code>: Captures the value of the first infusion dose.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">infratevar</span> <span class="pre">=</span> <span class="pre">variableName</span></code>: (Optional) Captures the <em>infusion rate</em> of the <em>first infusion dose</em>.</p></li>
</ul>
</li>
<li><p><strong>Bolus vs. Infusion:</strong></p>
<ul>
<li><p>If neither <code class="docutils literal notranslate"><span class="pre">duration</span></code> nor <code class="docutils literal notranslate"><span class="pre">rate</span></code> is specified, the dose is treated as a bolus (instantaneous).</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">duration</span></code> or <code class="docutils literal notranslate"><span class="pre">rate</span></code> is specified, the dose is treated as a zero-order infusion.</p></li>
</ul>
</li>
<li><p><strong>Multiple dosepoints:</strong> It is allowed to have several <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statements.</p></li>
<li><p><strong>dosepoint1 and dosepoint2:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">dosepoint1</span></code> is a direct synonym for <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dosepoint2</span></code> has a special function: it allows defining a
<em>second</em> dosing stream on the <em>same compartment</em> that already has
a <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> or <code class="docutils literal notranslate"><span class="pre">dosepoint1</span></code> defined. This is used for models
where a single dose is split into multiple administration profiles
(e.g., part bolus, part infusion).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">split</span></code> argument: When using <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> and <code class="docutils literal notranslate"><span class="pre">dosepoint2</span></code> on the same compartment to split a single dose
amount from your data, you <strong>must</strong> add the <code class="docutils literal notranslate"><span class="pre">split</span></code> argument to the first <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statement. This tells the system that the
<code class="docutils literal notranslate"><span class="pre">dose()</span></code> and <code class="docutils literal notranslate"><span class="pre">dose2()</span></code> mappings in the column definition file will both point to the <em>same data column</em> (e.g., <code class="docutils literal notranslate"><span class="pre">AMT</span></code>).</p></li>
</ul>
</li>
</ul>
<div class="admonition note" id="nlme-split">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Without <code class="docutils literal notranslate"><span class="pre">split</span></code>: The system would expect <code class="docutils literal notranslate"><span class="pre">dose()</span></code> and <code class="docutils literal notranslate"><span class="pre">dose2()</span></code> to map to two <em>different</em> amount columns (e.g., <code class="docutils literal notranslate"><span class="pre">AMT1</span></code>, <code class="docutils literal notranslate"><span class="pre">AMT2</span></code>).</p></li>
<li><p>With <code class="docutils literal notranslate"><span class="pre">split</span></code>: <code class="docutils literal notranslate"><span class="pre">dosepoint(Aa,</span> <span class="pre">bioavail=0.5,</span> <span class="pre">split)</span></code> and <code class="docutils literal notranslate"><span class="pre">dosepoint2(Aa,</span> <span class="pre">bioavail=0.5,</span> <span class="pre">...)</span></code> can both be sourced from a single <code class="docutils literal notranslate"><span class="pre">AMT</span></code> column.</p></li>
</ul>
</div>
<p><strong>Advanced Usage: Modeling with Multiple Dosepoints</strong></p>
<p>A powerful feature of PML is the ability to use multiple <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statements to model complex absorption. If two or more <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code>
statements exist, a single dose amount (<code class="docutils literal notranslate"><span class="pre">AMT</span></code>) from the input data can be programmatically split between them using the <code class="docutils literal notranslate"><span class="pre">bioavail</span></code>
option. The sum of the bioavailability fractions across all active pathways for a given dose should typically equal 1. This is the
foundation for modeling the parallel and sequential absorption schemes used for advanced drug formulations.</p>
<p>See <a class="reference internal" href="#nlme-modeling-complex-absorption-schemes"><span class="std std-ref">Modeling Complex Absorption Schemes</span></a> for detailed examples.</p>
<p><strong>Example (Bolus dose with lag time):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>dosepoint(Aa, tlag = 0.5)  // Bolus dose to Aa with a 0.5 time unit lag
</pre></div>
</div>
<p><strong>Example (Zero-order infusion with bioavailability):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>dosepoint(A1, duration = 2, bioavail = 0.8)  // Infusion to A1 over 2 time units, 80% bioavailability
</pre></div>
</div>
<p><strong>Example (Capturing the first bolus dose to use it in the secondary statement):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>dosepoint(A1, idosevar = FirstDose)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A dosepoint statement is REQUIRED for any compartment that receives doses. Without a dosepoint statement, even if
your input dataset contains AMT values for that compartment, no dosing will occur in the model.</p>
</div>
<p><strong>NONMEM Equivalent:</strong> * Bolus dose: In NONMEM, you’d typically use the <code class="docutils literal notranslate"><span class="pre">AMT</span></code> column in your dataset along with an appropriate <code class="docutils literal notranslate"><span class="pre">EVID</span></code> value
(usually 1) to indicate a bolus dose. * Infusion: In NONMEM, you’d use <code class="docutils literal notranslate"><span class="pre">AMT</span></code>, <code class="docutils literal notranslate"><span class="pre">RATE</span></code> (or <code class="docutils literal notranslate"><span class="pre">DUR</span></code>), and an <code class="docutils literal notranslate"><span class="pre">EVID</span></code> value (usually 4 for
infusions). * <code class="docutils literal notranslate"><span class="pre">tlag</span></code>: Similar to NONMEM’s <code class="docutils literal notranslate"><span class="pre">ALAG</span></code> * <code class="docutils literal notranslate"><span class="pre">bioavail</span></code>: Similar to NONMEM’s <code class="docutils literal notranslate"><span class="pre">F</span></code> * <code class="docutils literal notranslate"><span class="pre">idosevar</span></code>, <code class="docutils literal notranslate"><span class="pre">infdosevar</span></code>,
<code class="docutils literal notranslate"><span class="pre">infratevar</span></code>: There aren’t direct NONMEM equivalents. You might use workarounds with additional parameters or data items.</p>
<p><strong>Keywords:</strong> dosepoint, dose, dosing, bolus, infusion, tlag, duration, rate, bioavail, dobefore, doafter, idosevar, infdosevar, infratevar, split, dosepoint1, dosepoint2</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-sequence"><span class="std std-ref">sequence</span></a>, <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a>, Bioavailability</p>
</section>
<section id="urinecpt">
<span id="nlme-urinecpt"></span><h3>urinecpt<a class="headerlink" href="#urinecpt" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">urinecpt</span></code> statement defines an elimination
compartment, similar to <code class="docutils literal notranslate"><span class="pre">deriv</span></code>, but with specific behavior during
steady-state dosing: it’s ignored.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To model the elimination of drug or a metabolite into an
accumulating compartment (typically urine).</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">urinecpt(variable</span> <span class="pre">=</span> <span class="pre">expression</span> <span class="pre">[,</span> <span class="pre">fe</span> <span class="pre">=</span> <span class="pre">fractionExp])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">variable</span></code>: The name of the elimination compartment amount.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expression</span></code>: Defines the rate of elimination <em>into</em> the
compartment.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fe</span> <span class="pre">=</span> <span class="pre">fractionExp</span></code>: (Optional) Specifies fraction excreted</p></li>
</ul>
</li>
<li><p><strong>Steady-State Behavior:</strong> The key difference between <code class="docutils literal notranslate"><span class="pre">urinecpt</span></code>
and <code class="docutils literal notranslate"><span class="pre">deriv</span></code> is that during <em>steady-state</em> simulations, the
<code class="docutils literal notranslate"><span class="pre">urinecpt</span></code> statement is <em>ignored</em>. This is because, at steady
state, the amount in the elimination compartment is not relevant to
the dynamics of the system.</p></li>
<li><p><strong>Resetting:</strong> The amount in the compartment could be set to 0 after
being observed using observe statement and <code class="docutils literal notranslate"><span class="pre">doafter</span></code> option.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>urinecpt(A0 = Cl * C)  // Elimination compartment, rate proportional to concentration
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> There isn’t a direct equivalent in NONMEM. You’d often model urine excretion using a regular compartment (<code class="docutils literal notranslate"><span class="pre">$DES</span></code> or
built-in <code class="docutils literal notranslate"><span class="pre">ADVAN</span></code> subroutine) and then, if needed for steady-state calculations, you would manually ensure that the urine compartment’s
contribution is handled appropriately (often by not including it in the objective function calculation at steady state).</p>
<p><strong>Keywords:</strong> urinecpt, elimination compartment, excretion, steady-state</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-deriv"><span class="std std-ref">deriv</span></a>, <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a>, Elimination, Steady State</p>
</section>
</section>
<section id="observation-and-error-models">
<span id="nlme-observation-and-error-models"></span><h2>Observation and Error Models<a class="headerlink" href="#observation-and-error-models" title="Link to this heading">¶</a></h2>
<section id="observe">
<span id="nlme-observe"></span><h3>observe<a class="headerlink" href="#observe" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">observe</span></code> statement links model predictions to
observed data, defining the residual error structure. Crucially, each
<code class="docutils literal notranslate"><span class="pre">observe</span></code> statement must include <em>exactly one</em> error variable. It also
handles below-quantification-limit (BQL) data.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To connect model-predicted values to observed data and
define how the model accounts for the difference (residual error)
between them.</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">observe(observedVariable</span> <span class="pre">=</span> <span class="pre">expression</span> <span class="pre">[,</span> <span class="pre">bql[</span> <span class="pre">=</span> <span class="pre">value]][,</span> <span class="pre">actionCode])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">observedVariable</span></code>: The name of the observed variable (e.g.,
<code class="docutils literal notranslate"><span class="pre">CObs</span></code>, <code class="docutils literal notranslate"><span class="pre">EObs</span></code>, <code class="docutils literal notranslate"><span class="pre">Resp</span></code>). This variable will be mapped to a
column in your input data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expression</span></code>: Defines the <em>predicted</em> value. This expression
<em>must</em> include exactly one error variable (defined using an
<code class="docutils literal notranslate"><span class="pre">error</span></code> statement). The form of this expression, together with
the <code class="docutils literal notranslate"><span class="pre">error</span></code> statement, determines the error model (additive,
proportional, etc.).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bql</span></code>: (Optional) Handles below-quantification-limit (BQL) data
using the M3 method. See the separate entry on “BQL Handling” for
details.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">bql</span></code>: Uses dynamic LLOQ, requiring a mapped <code class="docutils literal notranslate"><span class="pre">CObsBQL</span></code>
column (or equivalent).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bql</span> <span class="pre">=</span> <span class="pre">&lt;value&gt;</span></code>: Uses a static LLOQ <em>value</em>. <strong>Important:</strong>
This must be a numeric literal, <em>not</em> an expression.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">actionCode</span></code>: (Optional) Allows executing code (<code class="docutils literal notranslate"><span class="pre">sequence</span></code>
block) before or after the observation (using <code class="docutils literal notranslate"><span class="pre">dobefore</span></code> or
<code class="docutils literal notranslate"><span class="pre">doafter</span></code>).</p></li>
</ul>
</li>
<li><p><strong>Single Error Variable Restriction:</strong> This is a <em>key difference</em>
from NONMEM. PML allows <em>only one</em> error variable per <code class="docutils literal notranslate"><span class="pre">observe</span></code>
statement. NONMEM allows combining multiple <code class="docutils literal notranslate"><span class="pre">EPS</span></code> terms (e.g.,
<code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">=</span> <span class="pre">F*EXP(EPS(1))</span> <span class="pre">+</span> <span class="pre">EPS(2)</span></code>). In PML, you achieve combined error
models using specific functional forms within the <code class="docutils literal notranslate"><span class="pre">expression</span></code>,
<em>not</em> by adding multiple error variables.</p></li>
<li><p><strong>Common Error Models (and how to express them in PML):</strong></p>
<ul>
<li><p><strong>Additive:</strong> <code class="docutils literal notranslate"><span class="pre">observe(CObs</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">+</span> <span class="pre">CEps)</span></code></p>
<ul>
<li><p>Observed value (<code class="docutils literal notranslate"><span class="pre">CObs</span></code>) equals the predicted value (<code class="docutils literal notranslate"><span class="pre">C</span></code>)
plus an error term (<code class="docutils literal notranslate"><span class="pre">CEps</span></code>). The error is constant regardless
of the prediction’s magnitude.</p></li>
</ul>
</li>
<li><p><strong>Proportional:</strong> <code class="docutils literal notranslate"><span class="pre">observe(CObs</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">CEps))</span></code> or
<code class="docutils literal notranslate"><span class="pre">observe(CObs</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">*</span> <span class="pre">exp(CEps))</span></code></p>
<ul>
<li><p>The error is proportional to the predicted value.
<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">CEps)</span></code> is a common approximation. <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">*</span> <span class="pre">exp(CEps)</span></code>
is a log-additive form, ensuring positivity.</p></li>
</ul>
</li>
<li><p><strong>Combined Additive and Proportional:</strong> PML provides two main ways to express this:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">additiveMultiplicative</span></code> <strong>(Built-in Form)</strong>:
<code class="docutils literal notranslate"><span class="pre">observe(CObs</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">+</span> <span class="pre">CEps</span> <span class="pre">*</span> <span class="pre">sqrt(1</span> <span class="pre">+</span> <span class="pre">C^2</span> <span class="pre">*</span> <span class="pre">(EMultStdev</span> <span class="pre">/</span> <span class="pre">sigma())^2))</span>&#160;&#160;&#160;&#160; <span class="pre">error(CEps</span> <span class="pre">=</span> <span class="pre">...)</span> <span class="pre">//</span> <span class="pre">Define</span> <span class="pre">CEps</span> <span class="pre">as</span> <span class="pre">usual</span></code>
This form is mathematically equivalent to a combined additive
and proportional error model and is often preferred for its
numerical stability. <code class="docutils literal notranslate"><span class="pre">EMultStdev</span></code> represents the proportional
error standard deviation, and <code class="docutils literal notranslate"><span class="pre">sigma()</span></code> represents the total
variance when C=0.</p></li>
<li><p><strong>Using a Mixing Parameter (MixRatio):</strong>
<code class="docutils literal notranslate"><span class="pre">stparm(CMixRatio</span> <span class="pre">=</span> <span class="pre">tvCMixRatio)</span> <span class="pre">//</span> <span class="pre">Define</span> <span class="pre">a</span> <span class="pre">structural</span> <span class="pre">parameter</span>&#160;&#160;&#160;&#160; <span class="pre">fixef(tvCMixRatio</span> <span class="pre">=</span> <span class="pre">c(,</span> <span class="pre">0.1,</span> <span class="pre">))</span>&#160; <span class="pre">//</span> <span class="pre">And</span> <span class="pre">its</span> <span class="pre">fixed</span> <span class="pre">effect</span>&#160;&#160;&#160;&#160; <span class="pre">error(CEps</span> <span class="pre">=</span> <span class="pre">...)</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">//</span> <span class="pre">Define</span> <span class="pre">the</span> <span class="pre">error</span> <span class="pre">variable</span>&#160;&#160;&#160;&#160; <span class="pre">observe(CObs</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">+</span> <span class="pre">CEps</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">*</span> <span class="pre">CMixRatio))</span></code>
This approach is more flexible and allows for easier
interpretation of the mixing parameter.</p></li>
</ul>
</li>
<li><p><strong>Power:</strong> <code class="docutils literal notranslate"><span class="pre">observe(Obs</span> <span class="pre">=</span> <span class="pre">Pred</span> <span class="pre">+</span> <span class="pre">(Pred^power)*Eps)</span></code></p>
<ul>
<li><p>The error term’s magnitude scales with the predicted value
raised to the power of power.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Multiple observe Statements:</strong> Use separate <code class="docutils literal notranslate"><span class="pre">observe</span></code>
statements for <em>each</em> observed variable (e.g., one for plasma
concentration, one for a PD response). Each <code class="docutils literal notranslate"><span class="pre">observe</span></code> statement
defines its <em>own</em> observed variable, predicted value, and error
structure.</p></li>
</ul>
<p><strong>Example (Proportional Error):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>error(CEps = 0.1)  // Define the error variable and its SD
observe(CObs = C * (1 + CEps)) // Proportional error
</pre></div>
</div>
<p><strong>Example (Combined Error - additiveMultiplicative):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>error(CEps = 0.05) // Additive error SD
observe(CObs = C + CEps * sqrt(1 + C^2*(0.2/sigma())^2))  // Combined, EMultStdev=0.2
</pre></div>
</div>
<p><strong>Example (Combined Error - MixRatio):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>stparm(CMixRatio = tvCMixRatio)
fixef(tvCMixRatio = c(, 0.1, ))
error(CEps = 0.05)
observe(CObs = C + CEps * (1 + C * CMixRatio)) // Combined error
</pre></div>
</div>
<p><strong>Example (Multiple Observations - PK and PD):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>error(CEps = 0.1)
observe(CObs = C * (1 + CEps)) // PK observation

error(EEps = 2)
observe(EObs = E + EEps)  // PD observation (additive error)
</pre></div>
</div>
<p><strong>NONMEM Translation Note:</strong> When translating from NONMEM, remember that PML <em>cannot</em> directly combine multiple <code class="docutils literal notranslate"><span class="pre">EPS</span></code> terms in a single
<code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">=</span> <span class="pre">...</span></code> line. You <em>must</em> use PML’s built-in combined error forms (<code class="docutils literal notranslate"><span class="pre">additiveMultiplicative</span></code> or the <code class="docutils literal notranslate"><span class="pre">MixRatio</span></code> approach) or define a
custom likelihood using the <code class="docutils literal notranslate"><span class="pre">LL</span></code> statement. NONMEM’s <code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">=</span> <span class="pre">F*EXP(EPS(1))</span> <span class="pre">+</span> <span class="pre">EPS(2)</span></code> is <em>approximated</em> in PML by the
<code class="docutils literal notranslate"><span class="pre">additiveMultiplicative</span></code> form, as NONMEM uses a linear approximation for <code class="docutils literal notranslate"><span class="pre">EXP(EPS)</span></code> when the variances are small.</p>
<p><strong>Keywords:</strong> observe, observation, error model, residual error, additive, proportional, combined, additiveMultiplicative, bql, censored data, M3 method</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-error"><span class="std std-ref">error</span></a>, <a class="reference internal" href="#nlme-error-models"><span class="std std-ref">Error Models</span></a>, <a class="reference internal" href="#nlme-bql-handling"><span class="std std-ref">BQL Handling</span></a>, <code class="docutils literal notranslate"><span class="pre">LL</span></code>, <a class="reference internal" href="#nlme-data-mapping"><span class="std std-ref">Data Mapping</span></a>, <code class="docutils literal notranslate"><span class="pre">additiveMultiplicative</span></code></p>
</section>
<section id="error">
<span id="nlme-error"></span><h3>error<a class="headerlink" href="#error" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">error</span></code> statement defines a residual error variable
and its standard deviation. This variable is <em>required</em> for use within
an <code class="docutils literal notranslate"><span class="pre">observe</span></code> statement.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To declare a residual error variable (often named with
an “Eps” suffix) and specify its initial standard deviation.</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">error(errorVariable[(freeze)]</span> <span class="pre">=</span> <span class="pre">standardDeviation)</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">errorVariable</span></code>: The name of the error variable (e.g., <code class="docutils literal notranslate"><span class="pre">CEps</span></code>,
<code class="docutils literal notranslate"><span class="pre">EEps</span></code>). This name <em>must</em> be used in the corresponding
<code class="docutils literal notranslate"><span class="pre">observe</span></code> statement.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">freeze</span></code>: (Optional) If present, the standard deviation is
<em>fixed</em> at the given value and <em>not</em> estimated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">standardDeviation</span></code>: A <em>numeric literal</em> (e.g., <code class="docutils literal notranslate"><span class="pre">0.1</span></code>,
<code class="docutils literal notranslate"><span class="pre">2.5</span></code>) representing the initial estimate for the standard
deviation.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This must be a simple number. It cannot be an expression, a function call (like <code class="docutils literal notranslate"><span class="pre">sqrt()</span></code>), or a variable.</p>
</div>
<ul class="simple">
<li><p><strong>Default Value:</strong> If the standard deviation is not provided, the
default value is 1. But not providing it is a bad practice.</p></li>
<li><p><strong>Multiple error Statements:</strong> You need one <code class="docutils literal notranslate"><span class="pre">error</span></code> statement
for <em>each</em> error variable used in your model (usually one per
<code class="docutils literal notranslate"><span class="pre">observe</span></code> statement).</p></li>
<li><p><strong>Recommended placement:</strong> before <code class="docutils literal notranslate"><span class="pre">observe</span></code> statement.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>error(CEps = 0.1)       // Error variable CEps, SD = 0.1
error(EEps(freeze) = 5) // Error variable EEps, fixed SD = 5

// INCORRECT - standardDeviation cannot be an expression:
// error(CEps = sqrt(0.04))

// CORRECT - Use the numeric value directly
error(CEps = 0.2) // Equivalent to sqrt(0.04) - standard deviation, not variance
</pre></div>
</div>
<p><strong>Important Notes (CRITICAL)</strong>:</p>
<ul class="simple">
<li><p>Standard Deviation, NOT Variance: The standardDeviation in the error
statement must be the standard deviation, NOT the variance. If you
are translating a model from NONMEM, remember that the $SIGMA block
often defines variances. You must take the square root of the NONMEM
variance to obtain the correct standard deviation for PML.</p>
<ul>
<li><p>Example: If NONMEM has $SIGMA 0.09, the corresponding PML would be
error(CEps = 0.3) (because the square root of 0.09 is 0.3).</p></li>
</ul>
</li>
<li><p>Numeric Literal Requirement: The standardDeviation must be a numeric
literal. It cannot be an expression, a variable, or a function call.</p></li>
</ul>
<p><strong>NONMEM Equivalent:</strong> The <code class="docutils literal notranslate"><span class="pre">error</span></code> statement combined with the error
model specification in <code class="docutils literal notranslate"><span class="pre">observe</span></code> is conceptually similar to defining
error terms in NONMEM’s <code class="docutils literal notranslate"><span class="pre">$ERROR</span></code> block (or within
<code class="docutils literal notranslate"><span class="pre">$PRED</span></code>/<code class="docutils literal notranslate"><span class="pre">$PREDPP</span></code>). The <code class="docutils literal notranslate"><span class="pre">freeze</span></code> keyword corresponds to fixing the
associated <code class="docutils literal notranslate"><span class="pre">SIGMA</span></code> parameter in NONMEM. <strong>Important Difference:</strong>
NONMEM’s <code class="docutils literal notranslate"><span class="pre">$SIGMA</span></code> represents <em>variance</em>, while PML’s <code class="docutils literal notranslate"><span class="pre">error</span></code>
statement <em>always</em> expects the <em>standard deviation</em>. You <em>must</em> take the
square root of the variance from NONMEM’s <code class="docutils literal notranslate"><span class="pre">$SIGMA</span></code> when translating to
PML’s <code class="docutils literal notranslate"><span class="pre">error</span></code>.</p>
<p><strong>Keywords:</strong> error, residual error, error variable, epsilon, standard deviation, freeze</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-observe"><span class="std std-ref">observe</span></a>, <a class="reference internal" href="#nlme-error-models"><span class="std std-ref">Error Models</span></a>, Residual Error</p>
</section>
<section id="error-models">
<span id="nlme-error-models"></span><h3>Error Models<a class="headerlink" href="#error-models" title="Link to this heading">¶</a></h3>
<p>Error models describe how the model accounts for the
difference between predicted and observed values. Common models include
additive, proportional, combined, and power.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To quantify the discrepancy between model predictions
and observations, reflecting measurement error, biological
variability, and model misspecification.</p></li>
<li><p><strong>Common Error Models (Review - with emphasis on PML
implementation):</strong></p>
<ul>
<li><p><strong>Additive:</strong> <code class="docutils literal notranslate"><span class="pre">Observed</span> <span class="pre">=</span> <span class="pre">Predicted</span> <span class="pre">+</span> <span class="pre">Error</span></code></p>
<ul>
<li><p>PML: <code class="docutils literal notranslate"><span class="pre">observe(Obs</span> <span class="pre">=</span> <span class="pre">Pred</span> <span class="pre">+</span> <span class="pre">Eps)</span></code></p></li>
<li><p>Error is constant, regardless of prediction.</p></li>
</ul>
</li>
<li><p><strong>Proportional:</strong> <code class="docutils literal notranslate"><span class="pre">Observed</span> <span class="pre">=</span> <span class="pre">Predicted</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">Error)</span></code> or
<code class="docutils literal notranslate"><span class="pre">Observed</span> <span class="pre">=</span> <span class="pre">Predicted</span> <span class="pre">*</span> <span class="pre">exp(Error)</span></code></p>
<ul>
<li><p>PML: <code class="docutils literal notranslate"><span class="pre">observe(Obs</span> <span class="pre">=</span> <span class="pre">Pred</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">Eps))</span></code> (approximation) or
<code class="docutils literal notranslate"><span class="pre">observe(Obs</span> <span class="pre">=</span> <span class="pre">Pred</span> <span class="pre">*</span> <span class="pre">exp(Eps))</span></code> (log-additive)</p></li>
<li><p>Error is proportional to the prediction.</p></li>
</ul>
</li>
<li><p><strong>Log-additive</strong>: <code class="docutils literal notranslate"><span class="pre">observe(CObs</span> <span class="pre">=</span> <span class="pre">C*exp(Eps))</span></code></p></li>
<li><p><strong>Combined Additive and Proportional:</strong></p>
<ul>
<li><p>PML (Preferred - <code class="docutils literal notranslate"><span class="pre">additiveMultiplicative</span></code>):
<code class="docutils literal notranslate"><span class="pre">observe(CObs</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">+</span> <span class="pre">CEps</span> <span class="pre">*</span> <span class="pre">sqrt(1</span> <span class="pre">+</span> <span class="pre">C^2</span> <span class="pre">*</span> <span class="pre">(EMultStdev</span> <span class="pre">/</span> <span class="pre">sigma())^2))</span>&#160;&#160;&#160;&#160; <span class="pre">error(CEps</span> <span class="pre">=</span> <span class="pre">...)</span> <span class="pre">//</span> <span class="pre">Define</span> <span class="pre">CEps</span> <span class="pre">as</span> <span class="pre">usual</span></code>
Where ‘EMultStdev’ is proportional error standard deviation,
and ‘sigma()’ represents the variance when C=0.</p></li>
<li><p>PML (Using <code class="docutils literal notranslate"><span class="pre">MixRatio</span></code>):
<code class="docutils literal notranslate"><span class="pre">stparm(CMixRatio</span> <span class="pre">=</span> <span class="pre">tvCMixRatio)</span>&#160;&#160;&#160;&#160; <span class="pre">fixef(tvCMixRatio</span> <span class="pre">=</span> <span class="pre">c(,</span> <span class="pre">0.1,</span> <span class="pre">))</span>&#160;&#160;&#160;&#160; <span class="pre">error(CEps</span> <span class="pre">=</span> <span class="pre">...)</span>&#160;&#160;&#160;&#160; <span class="pre">observe(CObs</span> <span class="pre">=</span> <span class="pre">C</span> <span class="pre">+</span> <span class="pre">CEps</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">C</span> <span class="pre">*</span> <span class="pre">CMixRatio))</span></code></p></li>
</ul>
</li>
<li><p><strong>Power:</strong> <code class="docutils literal notranslate"><span class="pre">Observed</span> <span class="pre">=</span> <span class="pre">Predicted</span> <span class="pre">+</span> <span class="pre">(Predicted^power)</span> <span class="pre">*</span> <span class="pre">Error</span></code></p>
<ul>
<li><p>PML: <code class="docutils literal notranslate"><span class="pre">observe(Obs</span> <span class="pre">=</span> <span class="pre">Pred</span> <span class="pre">+</span> <span class="pre">(Pred^power)*Eps)</span></code></p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Choosing an Error Model:</strong> Select a model that reflects how
variability changes with the magnitude of the predicted value.</p></li>
</ul>
<p><strong>Keywords:</strong> error model, residual error, additive, proportional, combined, additiveMultiplicative, log-additive, power</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-observe"><span class="std std-ref">observe</span></a>, <a class="mono reference internal" href="#nlme-error"><span class="std std-ref">error</span></a>, Residual Error, <code class="docutils literal notranslate"><span class="pre">additiveMultiplicative</span></code></p>
</section>
<section id="bql-handling">
<span id="nlme-bql-handling"></span><h3>BQL Handling<a class="headerlink" href="#bql-handling" title="Link to this heading">¶</a></h3>
<p>Below Quantification Limit (BQL) data occurs when the true
value is below the assay’s detection limit. PML handles BQL data using
the M3 method within the <code class="docutils literal notranslate"><span class="pre">observe</span></code> statement.</p>
<ul class="simple">
<li><p><strong>Problem:</strong> BQL data are <em>censored</em>; we only know the value is below
a limit (the LOQ).</p></li>
<li><p><strong>M3 Method:</strong> Standard approach (Beal, 2001). Calculates the
<em>probability</em> of the true value being below the LOQ.</p></li>
<li><p><strong>PML Implementation:</strong> The <code class="docutils literal notranslate"><span class="pre">observe</span></code> statement’s <code class="docutils literal notranslate"><span class="pre">bql</span></code> option
implements the M3 method.</p></li>
<li><p><strong>Two Ways to Use bql:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">observe(Obs</span> <span class="pre">=</span> <span class="pre">...,</span> <span class="pre">bql)</span></code> <strong>(Dynamic LOQ):</strong></p>
<ul>
<li><p>Creates a derived column <code class="docutils literal notranslate"><span class="pre">ObsBQL</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">CObsBQL</span></code>).</p></li>
<li><p><em>Optionally</em> map a column to this flag.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ObsBQL</span> <span class="pre">=</span> <span class="pre">0</span></code> (or missing): Observation is <em>above</em> the LOQ.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ObsBQL</span> <span class="pre">=</span> <span class="pre">non-zero</span></code>: Observation is <em>at or below</em> the LOQ.
The <code class="docutils literal notranslate"><span class="pre">Obs</span></code> value <em>becomes</em> the LOQ.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">ObsBQL</span></code> is not mapped, then the values in <code class="docutils literal notranslate"><span class="pre">Obs</span></code> are
used.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">observe(Obs</span> <span class="pre">=</span> <span class="pre">...,</span> <span class="pre">bql</span> <span class="pre">=</span> <span class="pre">&lt;value&gt;)</span></code> <strong>(Static LOQ):</strong></p>
<ul>
<li><p>Defines a <em>fixed</em> LOQ <em>value</em> (numeric literal).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Obs</span></code> values less than <code class="docutils literal notranslate"><span class="pre">&lt;value&gt;</span></code> are treated as censored.</p></li>
<li><p>Mapping <code class="docutils literal notranslate"><span class="pre">ObsBQL</span></code> is optional; mapped values override the
static value.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Mapping:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">censor(CObsBQL)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loq(LOQ)</span></code></p></li>
</ul>
</li>
</ul>
<p><strong>Example (Dynamic LOQ):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>error(CEps = 0.1)
observe(CObs = C * (1 + CEps), bql)  // Dynamic BQL
// ... and in the column mappings:
// censor(CObsBQL) // Optional, for explicit BQL flags
// loq(LOQ)
</pre></div>
</div>
<p><strong>Example (Static LOQ):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>error(CEps = 0.1)
observe(CObs = C * (1 + CEps), bql = 0.05)  // Static LOQ of 0.05
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> In NONMEM, you’d use the <code class="docutils literal notranslate"><span class="pre">M3</span></code> method.</p>
<div class="highlight-nonmem notranslate"><div class="highlight"><pre><span></span>$ERROR
  CP=A(2)/V
  PROP=CP*RUVCV
  ADD=RUVSD
  SD=SQRT(PROP*PROP+ADD*ADD)
IF (DV.GE.LLOQ) THEN
  F_FLAG=0 ; ELS
  Y=CP + SD*EPS1
ELSE
  F_FLAG=1 ; LIKELIHOOD
 Y=PHI((LLOQ-CP)/SD))
ENDIF
</pre></div>
</div>
<p><strong>Keywords:</strong> BQL, below quantification limit, censored data, M3 method, observe, bql, CObsBQL, LOQ</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-observe"><span class="std std-ref">observe</span></a>, <a class="reference internal" href="#nlme-error-models"><span class="std std-ref">Error Models</span></a>, <a class="reference internal" href="#nlme-data-mapping"><span class="std std-ref">Data Mapping</span></a>, Censored Data</p>
</section>
<section id="finding-extrema-peak-function-and-alternative-methods">
<h3>Finding Extrema (peak function and alternative methods)<a class="headerlink" href="#finding-extrema-peak-function-and-alternative-methods" title="Link to this heading">¶</a></h3>
<p>PML provides the <code class="docutils literal notranslate"><span class="pre">peak</span></code> function for automatically
finding the maximum (peak) or minimum (trough) values of a model
variable (typically concentration) and the corresponding times. An
alternative, more manual method using conditional logic is also
possible. Both approaches write results to <em>output tables</em>.</p>
<p>PML offers two primary methods for identifying and capturing the maximum
(Cmax, Tmax) and minimum (Cmin, Tmin) values of a model variable
(usually concentration, <code class="docutils literal notranslate"><span class="pre">C</span></code>) over time:</p>
<ol class="arabic">
<li><p><strong>The peak Function (Automatic, with Interpolation):</strong></p>
<ul class="simple">
<li><p><strong>Purpose:</strong> Automatically finds and reports the peak (maximum) or
trough (minimum) of a specified variable, along with the time at
which it occurs. Uses Lagrange interpolation for more precise
estimation.</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">variableName</span> <span class="pre">=</span> <span class="pre">peak(internalVariableName</span> <span class="pre">=</span> <span class="pre">expression,</span> <span class="pre">[max/min]</span> <span class="pre">[,</span> <span class="pre">logicalExpression])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">variableName</span></code>: A user-defined variable name to store the
<em>time</em> of the extremum (e.g., <code class="docutils literal notranslate"><span class="pre">Tmax</span></code>, <code class="docutils literal notranslate"><span class="pre">Tmin</span></code>). This
variable will be written to the output table.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">internalVariableName</span></code>: A user-defined variable to store the
value. It is used internally by the <code class="docutils literal notranslate"><span class="pre">peak()</span></code> function and
<em>should not be declared anywhere else</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expression</span></code>: The expression to track (usually the
concentration, <code class="docutils literal notranslate"><span class="pre">C</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max/min</span></code>: (Optional) Specifies whether to find the maximum
(<code class="docutils literal notranslate"><span class="pre">max</span></code>, default) or minimum (<code class="docutils literal notranslate"><span class="pre">min</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">logicalExpression</span></code>: (Optional) A logical expression (e.g.,
<code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&lt;</span> <span class="pre">6</span></code>) that restricts the search. If the expression is
<em>true</em>, the function searches for a peak/trough as specified.
If <em>false</em>, it searches for the <em>opposite</em> (trough if <code class="docutils literal notranslate"><span class="pre">max</span></code>,
peak if <code class="docutils literal notranslate"><span class="pre">min</span></code>).</p></li>
</ul>
</li>
<li><p><strong>Behavior:</strong></p>
<ul>
<li><p><strong>Initialization:</strong> Before the first peak/trough is found (or
after a <code class="docutils literal notranslate"><span class="pre">peakreset</span></code>), the output variables (<code class="docutils literal notranslate"><span class="pre">variableName</span></code>
and the <code class="docutils literal notranslate"><span class="pre">internalVariableName</span></code> ) will be blank (missing) in
the output table.</p></li>
<li><p><strong>Detection:</strong> The <code class="docutils literal notranslate"><span class="pre">peak</span></code> function continuously monitors the
<code class="docutils literal notranslate"><span class="pre">expression</span></code> and uses a 4-point window to detect potential
extrema. It uses Lagrange interpolation on these points to
estimate the precise time and value of the peak/trough.</p></li>
<li><p><strong>Updating:</strong> Once a peak/trough is found, the <code class="docutils literal notranslate"><span class="pre">variableName</span></code>
(time) and corresponding value are written to the output table.
Subsequent peaks/troughs will <em>only</em> update these values if
they are higher/lower (for max/min, respectively) than the
previously found extremum.</p></li>
<li><p>If the optional logical expression is defined, the extremum is
updated only when the logical expression holds true.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">peakreset</span></code>: The <code class="docutils literal notranslate"><span class="pre">peakreset(internalVariableName)</span></code> function resets the internal state of the <code class="docutils literal notranslate"><span class="pre">peak</span></code> function,
causing it to start searching for a new extremum from that point forward. This is crucial for finding multiple
peaks/troughs within a simulation. It is used in the <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block.</p></li>
</ul>
</li>
<li><p><strong>Restrictions:</strong></p>
<ul>
<li><p>Use only in the main model block, <em>not</em> in <code class="docutils literal notranslate"><span class="pre">sequence</span></code>, <code class="docutils literal notranslate"><span class="pre">dobefore</span></code>, or <code class="docutils literal notranslate"><span class="pre">doafter</span></code> blocks.</p></li>
</ul>
</li>
</ul>
<p><strong>Example (Finding Cmax and Tmax):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>Tmax = peak(Cmax = C, max) // Find the maximum concentration (Cmax) and its time (Tmax)
</pre></div>
</div>
<p><strong>Example (Finding Cmin and Tmin within a specific time window):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>Tmin = peak(Cmin = C, min = (t &gt;= 44 and t &lt;= 52)) // Find minimum between t=44 and t=52
</pre></div>
</div>
<p><strong>Example (Multiple peaks, using peakreset):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>sequence {
  sleep(44)  // Wait until the start of the interval of interest
  peakreset(Cmax) // Reset Cmax search
  peakreset(Cmin) // Reset Cmin search
  sleep(8)   // Observe for 8 time units
  peakreset(Cmax)
  peakreset(Cmin)
}

Tmax = peak(Cmax = C, max)
Tmin = peak(Cmin = C, min)
</pre></div>
</div>
<p><strong>Caution:</strong> The <code class="docutils literal notranslate"><span class="pre">peak</span></code> function uses cubic spline interpolation,
which can be sensitive to discontinuities (e.g., at the start/end of
an IV infusion). Ensure sufficient simulation output density around
potential extrema for accurate results.</p>
</li>
<li><p><strong>Manual Method (Using Conditional Logic):</strong></p>
<ul class="simple">
<li><p><strong>Purpose:</strong> Provides more control over the extremum-finding
process but requires more manual coding.</p></li>
<li><p><strong>Method:</strong> Use assignment statements and the <code class="docutils literal notranslate"><span class="pre">max</span></code> and <code class="docutils literal notranslate"><span class="pre">min</span></code>
functions within the main model block, combined with the ternary
operator (<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>) to track the highest/lowest values and
corresponding times. <em>All variables used with this method must be
initialized appropriately.</em></p>
<ul>
<li><p>Initialize <code class="docutils literal notranslate"><span class="pre">Cmax1</span></code> to a low value that is guaranteed to be
exceeded, e.g. -1e6</p></li>
<li><p>Initialize <code class="docutils literal notranslate"><span class="pre">Cmin1</span></code>to a high value, e.g., 1E6.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">max(current_value,</span> <span class="pre">previous_max)</span></code> to update the maximum.</p></li>
<li><p>Use <code class="docutils literal notranslate"><span class="pre">min(current_value,</span> <span class="pre">previous_min)</span></code> to update the minimum.</p></li>
<li><p>Use the ternary operator to update the time (<code class="docutils literal notranslate"><span class="pre">Tmax1</span></code>,
<code class="docutils literal notranslate"><span class="pre">Tmin1</span></code>) only when a new extremum is found.</p></li>
</ul>
</li>
<li><p><strong>Important:</strong> Unlike with the <code class="docutils literal notranslate"><span class="pre">peak</span></code> function, you must
initialize the variables used to store the maximum and minimum
values.</p></li>
</ul>
<p><strong>Example (Finding Cmax and Tmax manually):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>real(Cmax1, Tmax1, Cmin1, Tmin1)

sequence{
    Cmax1 = -1E6
    Cmin1 = 1E6
}

Cmax1 = max(C, Cmax1)
Tmax1 = (C == Cmax1 ? t : Tmax1)  // Update Tmax1 only when C equals the current Cmax1
Cmin1 = C &gt; 0 ? min(C, Cmin1) : 1E6 // use some big value until initialization
Tmin1 = C == Cmin1 ? t : Tmin1
</pre></div>
</div>
<p><strong>Advantages of Manual Method:</strong> Greater control, potentially more
robust in some situations with discontinuities (if carefully
implemented). <strong>Disadvantages of Manual Method:</strong> More code, requires
careful initialization, no built-in interpolation.</p>
</li>
</ol>
<p><strong>Key Differences Summarized:</strong></p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Feature</p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">peak</span></code> Function</p></th>
<th class="head"><p>Manual Method</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Initialization</p></td>
<td><p>Automatic (blanks
until first extremum)</p></td>
<td><p><em>Manual</em> (must
initialize Cmax1/Cmin1
to appropriate
low/high values)</p></td>
</tr>
<tr class="row-odd"><td><p>Interpolation</p></td>
<td><p>Yes (Lagrange)</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>Resetting</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">peakreset(i</span>
<span class="pre">nternalVariableName)</span></code></p></td>
<td><p>Manual logic
(typically
re-initializing in a
<code class="docutils literal notranslate"><span class="pre">sequence</span></code> block)</p></td>
</tr>
<tr class="row-odd"><td><p>Code Complexity</p></td>
<td><p>Less</p></td>
<td><p>More</p></td>
</tr>
<tr class="row-even"><td><p>Control</p></td>
<td><p>Less</p></td>
<td><p>More</p></td>
</tr>
<tr class="row-odd"><td><p>Discontinuities</p></td>
<td><p>Potentially sensitive
(ensure sufficient
output density)</p></td>
<td><p>Can be more robust if
handled carefully</p></td>
</tr>
<tr class="row-even"><td><p>Where to Use</p></td>
<td><p>Main model block (not
in <code class="docutils literal notranslate"><span class="pre">sequence</span></code>,
<code class="docutils literal notranslate"><span class="pre">dobefore</span></code>, or
<code class="docutils literal notranslate"><span class="pre">doafter</span></code>).</p></td>
<td><p>Main model block
(variables must be
declared with <code class="docutils literal notranslate"><span class="pre">real</span></code>
or <code class="docutils literal notranslate"><span class="pre">double</span></code> if
modified within
<code class="docutils literal notranslate"><span class="pre">sequence</span></code>).</p></td>
</tr>
<tr class="row-odd"><td><p>Output</p></td>
<td><p>Table Only</p></td>
<td><p>Table Only</p></td>
</tr>
</tbody>
</table>
<p><strong>NONMEM Equivalent:</strong> There’s no direct equivalent to PML’s <code class="docutils literal notranslate"><span class="pre">peak</span></code> function in NONMEM. NONMEM users typically implement custom code in
<code class="docutils literal notranslate"><span class="pre">$PRED</span></code> or <code class="docutils literal notranslate"><span class="pre">$PK</span></code> to find extrema, similar to the “Manual Method” described above. NONMEM does <em>not</em> have built-in Lagrange interpolation
for this purpose.</p>
<p><strong>Keywords:</strong> peak, trough, Cmax, Tmax, Cmin, Tmin, extremum, maximum, minimum, Lagrange interpolation, <code class="docutils literal notranslate"><span class="pre">peakreset</span></code>, table, output, simulation</p>
</section>
<section id="table-output">
<h3>Table Output<a class="headerlink" href="#table-output" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">table</span></code> statement, defined in the <em>column definition
file</em> (or equivalent interface), specifies which variables and events
should be included in the output table(s) generated by a PML model run.</p>
<ul>
<li><p><strong>Purpose:</strong> To control the generation of output tables containing
simulation results, observed data, and other model-related
information.</p></li>
<li><p><strong>Location:</strong> The <code class="docutils literal notranslate"><span class="pre">table</span></code> statement is <em>not</em> part of the PML code
itself. It’s defined in the <em>column definition file</em> (or equivalent
interface) used by the modeling software (e.g., Phoenix NLME).</p></li>
<li><p><strong>Syntax:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span><span class="p">(</span>
  <span class="p">[</span><span class="n">optionalFile</span><span class="p">]</span>
  <span class="p">[</span><span class="n">optionalDosepoints</span><span class="p">]</span>
  <span class="p">[</span><span class="n">optionalCovariates</span><span class="p">]</span>
  <span class="p">[</span><span class="n">optionalObservations</span><span class="p">]</span>
  <span class="p">[</span><span class="n">optionalTimes</span><span class="p">]</span>
  <span class="n">variableList</span>
<span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">optionalFile</span></code>: Specifies the output file name (e.g.,
<code class="docutils literal notranslate"><span class="pre">file=&quot;results.csv&quot;</span></code>). If omitted, a default file name is used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optionalDosepoints</span></code>: Specifies that output should be generated
at times when doses are administered to specific compartments
(e.g., <code class="docutils literal notranslate"><span class="pre">dose(A1,</span> <span class="pre">Aa)</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optionalCovariates</span></code>: Specifies that output should be generated
when the values of specified covariates change (e.g.,
<code class="docutils literal notranslate"><span class="pre">covr(Weight,</span> <span class="pre">Sex)</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optionalObservations</span></code>: Specifies that output should be
generated at times when specific observations are made (e.g.,
<code class="docutils literal notranslate"><span class="pre">obs(CObs,</span> <span class="pre">EObs)</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">optionalTimes</span></code>: Specifies explicit time points for output
generation. Can include:</p>
<ul>
<li><p>Individual time points: <code class="docutils literal notranslate"><span class="pre">time(0,</span> <span class="pre">1,</span> <span class="pre">2.5,</span> <span class="pre">5)</span></code></p></li>
<li><p>Sequences: <code class="docutils literal notranslate"><span class="pre">time(seq(0,</span> <span class="pre">10,</span> <span class="pre">0.1))</span></code> (generates 0, 0.1, 0.2,
…, 9.9, 10)</p></li>
<li><p>Combinations: <code class="docutils literal notranslate"><span class="pre">time(0,</span> <span class="pre">seq(1,</span> <span class="pre">5,</span> <span class="pre">0.5),</span> <span class="pre">10)</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">variableList</span></code>: A comma-separated list of variables to include
in the table. This can include:</p>
<ul>
<li><p>Observed variables (<code class="docutils literal notranslate"><span class="pre">CObs</span></code>, <code class="docutils literal notranslate"><span class="pre">EObs</span></code>, etc.)</p></li>
<li><p>Predicted variables (<code class="docutils literal notranslate"><span class="pre">C</span></code>, <code class="docutils literal notranslate"><span class="pre">E</span></code>, etc.)</p></li>
<li><p>Covariates (<code class="docutils literal notranslate"><span class="pre">Weight</span></code>, <code class="docutils literal notranslate"><span class="pre">Sex</span></code>, etc.)</p></li>
<li><p>Model parameters (fixed effects, <em>but not structural parameters
directly</em>)</p></li>
<li><p>Secondary parameters</p></li>
<li><p>User-defined variables for tracking extrema (e.g., <code class="docutils literal notranslate"><span class="pre">Tmax</span></code>,
<code class="docutils literal notranslate"><span class="pre">Cmax</span></code> from the <code class="docutils literal notranslate"><span class="pre">peak</span></code> function, or <code class="docutils literal notranslate"><span class="pre">Tmax1</span></code>, <code class="docutils literal notranslate"><span class="pre">Cmax1</span></code>
from the manual method)</p></li>
<li><p>Time (<code class="docutils literal notranslate"><span class="pre">t</span></code> or mapped time variable)</p></li>
<li><p>Other derived variables</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Multiple Tables:</strong> You can define multiple <code class="docutils literal notranslate"><span class="pre">table</span></code> statements to
generate different output tables with different contents and time
points.</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">table</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;results.csv&quot;</span><span class="p">,</span>
      <span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">seq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="mi">48</span><span class="p">),</span>  <span class="o">//</span> <span class="n">Output</span> <span class="n">at</span> <span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">every</span> <span class="mf">0.5</span> <span class="kn">from</span><span class="w"> </span><span class="mi">1</span> <span class="n">to</span> <span class="mi">24</span><span class="p">,</span> <span class="ow">and</span> <span class="n">at</span> <span class="n">t</span><span class="o">=</span><span class="mi">48</span>
      <span class="n">dose</span><span class="p">(</span><span class="n">A1</span><span class="p">),</span>                      <span class="o">//</span> <span class="n">Output</span> <span class="n">at</span> <span class="n">dose</span> <span class="n">times</span> <span class="n">to</span> <span class="n">compartment</span> <span class="n">A1</span>
      <span class="n">obs</span><span class="p">(</span><span class="n">CObs</span><span class="p">),</span>                   <span class="o">//</span> <span class="n">Output</span> <span class="n">at</span> <span class="n">observation</span> <span class="n">times</span> <span class="k">for</span> <span class="n">CObs</span>
      <span class="n">covr</span><span class="p">(</span><span class="n">Weight</span><span class="p">),</span>                <span class="o">//</span> <span class="n">Output</span> <span class="n">when</span> <span class="n">Weight</span> <span class="n">changes</span>
      <span class="n">C</span><span class="p">,</span> <span class="n">CObs</span><span class="p">,</span> <span class="n">Tmax</span><span class="p">,</span> <span class="n">Cmax</span><span class="p">,</span> <span class="n">Tmin</span><span class="p">,</span> <span class="n">Cmin</span>  <span class="o">//</span> <span class="n">Include</span> <span class="n">these</span> <span class="n">variables</span>
     <span class="p">)</span>

<span class="n">table</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;covariates.csv&quot;</span><span class="p">,</span>
      <span class="n">time</span><span class="p">(</span><span class="n">seq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">24</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span>
      <span class="n">covr</span><span class="p">(</span><span class="n">Weight</span><span class="p">,</span> <span class="n">Sex</span><span class="p">),</span>
      <span class="n">Weight</span><span class="p">,</span> <span class="n">Sex</span><span class="p">,</span> <span class="n">Age</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This defines two tables:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">results.csv</span></code>: Contains the predicted concentration (<code class="docutils literal notranslate"><span class="pre">C</span></code>),
observed concentration (<code class="docutils literal notranslate"><span class="pre">CObs</span></code>), time of maximum concentration
(<code class="docutils literal notranslate"><span class="pre">Tmax</span></code>), maximum concentration (<code class="docutils literal notranslate"><span class="pre">Cmax</span></code>), time of minimum
concentration (<code class="docutils literal notranslate"><span class="pre">Tmin</span></code>) and minimum concentration (<code class="docutils literal notranslate"><span class="pre">Cmin</span></code>) ,
generated at specified times, dose times, observation times, and when
<code class="docutils literal notranslate"><span class="pre">Weight</span></code> changes.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">covariates.csv</span></code>: Contains Weight, Sex and Age generated at
specified times and when <code class="docutils literal notranslate"><span class="pre">Weight</span></code> or <code class="docutils literal notranslate"><span class="pre">Sex</span></code>changes.</p></li>
</ol>
<p><strong>Important Notes:</strong></p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">table</span></code> statement controls <em>output</em>, not the model’s internal
calculations.</p></li>
<li><p>The order of variables in the <code class="docutils literal notranslate"><span class="pre">variableList</span></code> determines the order
of columns in the output table.</p></li>
<li><p>Time points specified in <code class="docutils literal notranslate"><span class="pre">optionalTimes</span></code> are automatically sorted.</p></li>
<li><p>Variables like <code class="docutils literal notranslate"><span class="pre">Tmax</span></code>, <code class="docutils literal notranslate"><span class="pre">Cmax</span></code> (from <code class="docutils literal notranslate"><span class="pre">peak</span></code> function or manual
method) should be added in output <em>tables</em>, not in <code class="docutils literal notranslate"><span class="pre">secondary</span></code>
statements.</p></li>
</ul>
<p><strong>Keywords:</strong> table, output, results, csv, data, time points, dosepoints, covariates, observations, <code class="docutils literal notranslate"><span class="pre">seq</span></code></p>
</section>
</section>
<section id="delays">
<span id="nlme-delays"></span><h2>Delays<a class="headerlink" href="#delays" title="Link to this heading">¶</a></h2>
<section id="delay">
<span id="nlme-delay"></span><h3>delay<a class="headerlink" href="#delay" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">delay</span></code> function introduces a time delay into a model. It can represent either a discrete delay (all signal mediators
have the same delay) or a distributed delay (delay times follow a distribution), modeling processes with a time lag.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To model time delays, either discrete or distributed, in a dynamic system.</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">delay(S,</span> <span class="pre">MeanDelayTime</span> <span class="pre">[,</span> <span class="pre">shape</span> <span class="pre">=</span> <span class="pre">ShapeParam][,</span> <span class="pre">hist</span> <span class="pre">=</span> <span class="pre">HistExpression][,</span> <span class="pre">dist</span> <span class="pre">=</span> <span class="pre">NameOfDistribution])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code>: The signal (expression) to be delayed. <em>Cannot directly depend on dose-related inputs</em>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeanDelayTime</span></code>: The mean delay time.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">ShapeParam</span></code>: (Optional) Shape parameter for the distribution (distributed delay). Interpretation depends on <code class="docutils literal notranslate"><span class="pre">dist</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">=</span> <span class="pre">Gamma</span></code> or <code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">=</span> <span class="pre">Weibull</span></code>: <code class="docutils literal notranslate"><span class="pre">ShapeParam</span></code> is the shape parameter <em>minus 1</em>. Must be non-negative.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">=</span> <span class="pre">InverseGaussian</span></code>: <code class="docutils literal notranslate"><span class="pre">ShapeParam</span></code> is the shape parameter itself.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">hist</span> <span class="pre">=</span> <span class="pre">HistExpression</span></code>: (Optional) The value of <code class="docutils literal notranslate"><span class="pre">S</span></code> <em>before</em> time 0 (the “history function”). If not provided, <code class="docutils literal notranslate"><span class="pre">S</span></code> is assumed to be 0 before time 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">=</span> <span class="pre">NameOfDistribution</span></code>: (Optional) The distribution: <code class="docutils literal notranslate"><span class="pre">Gamma</span></code> (default), <code class="docutils literal notranslate"><span class="pre">Weibull</span></code>, or <code class="docutils literal notranslate"><span class="pre">InverseGaussian</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Discrete vs. Distributed Delay:</strong></p>
<ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">shape</span></code> is <em>not</em> provided, a <em>discrete</em> delay is used: <code class="docutils literal notranslate"><span class="pre">S(t</span> <span class="pre">-</span> <span class="pre">MeanDelayTime)</span></code>.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">shape</span></code> <em>is</em> provided, a <em>distributed</em> delay is used (convolution of <code class="docutils literal notranslate"><span class="pre">S</span></code> with the distribution’s PDF).</p></li>
</ul>
</li>
<li><p><strong>Limitations:</strong></p>
<ul>
<li><p>Cannot be used with closed-form solutions (<code class="docutils literal notranslate"><span class="pre">cfMicro</span></code>, <code class="docutils literal notranslate"><span class="pre">cfMacro</span></code>) or matrix exponentiation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code> cannot directly depend on dose-related inputs. Use <code class="docutils literal notranslate"><span class="pre">delayInfCpt</span></code> for absorption delays.</p></li>
<li><p>Should be used sparingly</p></li>
</ul>
</li>
</ul>
<p><strong>Example (Discrete Delay):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>deriv(A = -k * delay(A, 2, hist = 10))  // A is delayed by 2 time units, initial value 10
sequence {A=10}
</pre></div>
</div>
<p><strong>Example (Distributed Delay - Gamma):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>deriv(A = -k * delay(A, 5, shape = 2, hist = 0, dist = Gamma)) // Gamma-distributed delay
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> There is no direct single-function equivalent in NONMEM. Delays, especially distributed delays, often require custom
coding in NONMEM using differential equations or user-defined subroutines.</p>
<p><strong>Keywords:</strong> delay, delay function, discrete delay, distributed delay, time delay, DDE, delay differential equation, gamma, Weibull, inverse Gaussian, hist</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-gammadelay"><span class="std std-ref">gammaDelay</span></a>, <a class="mono reference internal" href="#nlme-delayinfcpt"><span class="std std-ref">delayInfCpt</span></a>, Differential Equations, Time Delays, Distributed Delays</p>
</section>
<section id="gammadelay">
<span id="nlme-gammadelay"></span><h3>gammaDelay<a class="headerlink" href="#gammadelay" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">gammaDelay</span></code> function models a gamma-distributed
delay using an ODE approximation, which can be faster than the <code class="docutils literal notranslate"><span class="pre">delay</span></code>
function for complex models.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> Efficiently model a delay where the delay time follows a
gamma distribution.</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">gammaDelay(S,</span> <span class="pre">MeanDelayTime,</span> <span class="pre">shape</span> <span class="pre">=</span> <span class="pre">ShapeParam,</span> <span class="pre">[,</span> <span class="pre">hist</span> <span class="pre">=</span> <span class="pre">HistExpression],</span> <span class="pre">numODE</span> <span class="pre">=</span> <span class="pre">NumberOfODEUsed)</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">S</span></code>: The signal to be delayed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeanDelayTime</span></code>: The mean of the gamma distribution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shape</span> <span class="pre">=</span> <span class="pre">ShapeParam</span></code>: The shape parameter of the gamma
distribution. <em>Not</em> shape parameter minus one, unlike <code class="docutils literal notranslate"><span class="pre">delay</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hist</span> <span class="pre">=</span> <span class="pre">HistExpression</span></code>: (Optional) Value of <code class="docutils literal notranslate"><span class="pre">S</span></code> before time
0. Defaults to 0.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">numODE</span> <span class="pre">=</span> <span class="pre">NumberOfODEUsed</span></code>: (Required) Number of ODEs for the
approximation. Higher values are more accurate but slower. Maximum
value is 400.</p></li>
</ul>
</li>
<li><p><strong>ODE Approximation:</strong> <code class="docutils literal notranslate"><span class="pre">gammaDelay</span></code> approximates the convolution
integral with a system of ODEs.</p></li>
<li><p><strong>Accuracy and Performance:</strong> Accuracy depends on <code class="docutils literal notranslate"><span class="pre">numODE</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">ShapeParam</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>: Use at least 21 ODEs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ShapeParam</span> <span class="pre">&lt;=</span> <span class="pre">1</span></code>: Use at least 101 ODEs.</p></li>
</ul>
</li>
<li><p><strong>Advantages over delay:</strong> <code class="docutils literal notranslate"><span class="pre">gammaDelay</span></code> can be significantly faster than <code class="docutils literal notranslate"><span class="pre">delay(...,</span> <span class="pre">dist=Gamma)</span></code>.</p></li>
<li><p><strong>Limitations:</strong></p>
<ul>
<li><p>Only for gamma-distributed delays.</p></li>
<li><p>The signal to be delayed cannot depend directly on dose inputs</p></li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>deriv(A = -k * gammaDelay(A, 5, shape = 3, numODE = 30))  // Gamma-distributed delay
sequence {A=10}
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> There’s no direct equivalent in NONMEM. You’d typically implement a gamma-distributed delay using a series of transit
compartments, which approximates a gamma distribution.</p>
<p><strong>Keywords:</strong> gammaDelay, distributed delay, gamma distribution, approximation, ODE approximation, shape parameter</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-delay"><span class="std std-ref">delay</span></a>, Distributed Delays, Gamma Distribution, ODE Approximation</p>
</section>
<section id="delayinfcpt">
<span id="nlme-delayinfcpt"></span><h3>delayInfCpt<a class="headerlink" href="#delayinfcpt" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">delayInfCpt</span></code> statement models a distributed delay
<em>specifically for input into a compartment</em>. This is the correct way to
model absorption delays with a distributed delay time.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> Model distributed delays in the <em>absorption</em> process (or
any input into a compartment). Necessary because <code class="docutils literal notranslate"><span class="pre">delay</span></code> cannot
handle dose-related inputs directly.</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">delayInfCpt(A,</span> <span class="pre">MeanDelayTime,</span> <span class="pre">ParamRelatedToShape</span> <span class="pre">[,</span> <span class="pre">in</span> <span class="pre">=</span> <span class="pre">inflow][,</span> <span class="pre">out</span> <span class="pre">=</span> <span class="pre">outflow][,</span> <span class="pre">dist</span> <span class="pre">=</span> <span class="pre">NameOfDistribution])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">A</span></code>: The compartment receiving the delayed input. <em>Can</em> receive
doses via <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MeanDelayTime</span></code>: Mean of the delay time distribution.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ParamRelatedToShape</span></code>: Related to the shape parameter. Depends
on <code class="docutils literal notranslate"><span class="pre">dist</span></code>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">=</span> <span class="pre">InverseGaussian</span></code>: <code class="docutils literal notranslate"><span class="pre">ParamRelatedToShape</span></code> is the
shape parameter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">=</span> <span class="pre">Gamma</span></code> or <code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">=</span> <span class="pre">Weibull</span></code>: <code class="docutils literal notranslate"><span class="pre">ParamRelatedToShape</span></code>
is the shape parameter <em>minus 1</em>. Must be non-negative.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">=</span> <span class="pre">inflow</span></code>: (Optional) Additional inflow <em>into</em> compartment
<code class="docutils literal notranslate"><span class="pre">A</span></code> that should also be delayed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">outflow</span></code>: (Optional) Outflow <em>from</em> compartment <code class="docutils literal notranslate"><span class="pre">A</span></code>
that should <em>not</em> be delayed.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dist</span> <span class="pre">=</span> <span class="pre">NameOfDistribution</span></code>: (Optional) Delay time distribution:
<code class="docutils literal notranslate"><span class="pre">Gamma</span></code> (default), <code class="docutils literal notranslate"><span class="pre">Weibull</span></code>, or <code class="docutils literal notranslate"><span class="pre">InverseGaussian</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Relationship to dosepoint:</strong> Used <em>with</em> a <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statement for compartment <code class="docutils literal notranslate"><span class="pre">A</span></code>. <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> handles dosing, <code class="docutils literal notranslate"><span class="pre">delayInfCpt</span></code> models the delay.</p></li>
<li><p><strong>History function:</strong> is assumed to be zero</p></li>
</ul>
<p><strong>Example (One-compartment model with gamma-distributed absorption delay):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>delayInfCpt(A1, MeanDelayTime, ShapeParamMinusOne, out = -Cl * C)
dosepoint(A1)
C = A1 / V
</pre></div>
</div>
<p><strong>Example (Two-compartment model, two absorption pathways, each with
gamma delay):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>delayInfCpt(Ac1, MeanDelayTime1, ShapeParamMinusOne1, out = -Cl * C - Cl2 * (C - C2))
dosepoint(Ac1, bioavail = frac)  // Fraction &#39;frac&#39; goes through pathway 1
delayInfCpt(Ac2, MeanDelayTime2, ShapeParamMinusOne2)
dosepoint(Ac2, bioavail = 1 - frac) // Remaining fraction goes through pathway 2
deriv(A2 = Cl2 * (C - C2))
C = (Ac1 + Ac2) / V
C2 = A2 / V2
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> There isn’t a single, direct equivalent in NONMEM. You would likely use a combination of:</p>
<ul class="simple">
<li><p>An absorption compartment.</p></li>
<li><p>A series of transit compartments (to approximate a distributed delay, particularly a gamma distribution).</p></li>
<li><p>Potentially, user-defined subroutines (for more complex delay distributions).</p></li>
</ul>
<p><strong>Keywords:</strong> delayInfCpt, absorption delay, distributed delay, compartment, dosepoint, inflow, outflow, gamma, Weibull, inverse Gaussian</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-delay"><span class="std std-ref">delay</span></a>, <a class="mono reference internal" href="#nlme-gammadelay"><span class="std std-ref">gammaDelay</span></a>, <a class="mono reference internal" href="#nlme-dosepoint"><span class="std std-ref">dosepoint</span></a>, <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a>, Absorption Delay, Distributed Delays</p>
</section>
<section id="transit">
<h3>transit<a class="headerlink" href="#transit" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">transit</span></code> statement models the flow of material
through a series of linked compartments.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> <code class="docutils literal notranslate"><span class="pre">transit</span></code> statement can be used to model    the flow of material through a series of linked compartments</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">transit(dest,</span> <span class="pre">source,</span> <span class="pre">mtt,</span> <span class="pre">num</span> <span class="pre">[,</span> <span class="pre">in</span> <span class="pre">=</span> <span class="pre">inflow]</span> <span class="pre">[,</span> <span class="pre">out</span> <span class="pre">=</span> <span class="pre">outflow])</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">dest</span></code>: destination compartment</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">source</span></code>: source compartment, could be a dosepoint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mtt</span></code>: mean transit time</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">num</span></code>: number of transit compartments</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">=</span> <span class="pre">inflow</span></code>: (Optional) Specifies any additional inflow into destination compartment</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">out</span> <span class="pre">=</span> <span class="pre">outflow</span></code>: (Optional) Specifies any outflow from destination compartment</p></li>
</ul>
</li>
<li><p><strong>Restrictions:</strong> Cannot be used in a model with any closed-form statement</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>transit(A1, A0, mtt, num, out = - Cl * A1/V)
</pre></div>
</div>
<p><strong>NONMEM Equivalent:</strong> The transit statement is conceptually similar to setting up a series of compartments with first-order transfer between
them in NONMEM, but it handles the underlying equations more implicitly.</p>
<p><strong>Keywords:</strong> transit compartment, absorption</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a></p>
</section>
</section>
<section id="built-in-functions">
<span id="nlme-built-in-functions"></span><h2>Built-In Functions<a class="headerlink" href="#built-in-functions" title="Link to this heading">¶</a></h2>
<section id="built-in-mathematical-functions">
<h3>Built-In Mathematical Functions<a class="headerlink" href="#built-in-mathematical-functions" title="Link to this heading">¶</a></h3>
<p>PML provides a wide range of standard mathematical
functions that can be used in expressions within the model. These
functions operate on double-precision floating-point numbers.</p>
<ul class="simple">
<li><p><strong>Common Functions:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">sqrt(x)</span></code>: Square root of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exp(x)</span></code>: Exponential function (e^x).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">log(x)</span></code>: Natural logarithm (base e) of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">log10(x)</span></code>: Base-10 logarithm of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pow(x,</span> <span class="pre">y)</span></code>: <code class="docutils literal notranslate"><span class="pre">x</span></code> raised to the power of <code class="docutils literal notranslate"><span class="pre">y</span></code> (x^y).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">abs(x)</span></code>: Absolute value of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">min(x,</span> <span class="pre">y)</span></code>: Minimum of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max(x,</span> <span class="pre">y)</span></code>: Maximum of <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mod(x,</span> <span class="pre">y)</span></code>: Remainder of <code class="docutils literal notranslate"><span class="pre">x</span></code> divided by <code class="docutils literal notranslate"><span class="pre">y</span></code> (modulo operation).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sin(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">cos(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">tan(x)</span></code>: Trigonometric functions (input in radians).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">asin(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">acos(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">atan(x)</span></code>: Inverse trigonometric functions (output in radians).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sinh(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">cosh(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">tanh(x)</span></code>: Hyperbolic functions.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">asinh(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">acosh(x)</span></code>, <code class="docutils literal notranslate"><span class="pre">atanh(x)</span></code>: Inverse hyperbolic functions.</p></li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>stparm(
  Cl = tvCl * exp(nCl),
  V  = tvV * exp(nV),
  Ka = tvKa,
  F  = ilogit(tvF)    // Example of using ilogit
)
C = A / V
Rate = Cl * C
Halflife = log(2) / (Cl / V)  // Calculate half-life using log and division
</pre></div>
</div>
<p><strong>Keywords:</strong> mathematical functions, sqrt, exp, log, log10, pow, abs, min, max, mod, sin, cos, tan, asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="mono reference internal" href="#nlme-deriv"><span class="std std-ref">deriv</span></a></p>
</section>
<section id="link-and-inverse-link-functions">
<h3>Link and Inverse Link Functions<a class="headerlink" href="#link-and-inverse-link-functions" title="Link to this heading">¶</a></h3>
<p>Link and inverse link functions transform variables, often to constrain them to a specific range (e.g., probabilities between 0 and 1). They are important for modeling categorical/ordinal data.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To relate a linear predictor (which can be any real
number) to a parameter that has constraints (e.g., a probability).</p></li>
<li><p><strong>Common Functions:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">ilogit(x)</span></code>: Inverse logit function (sigmoid function). Calculates <code class="docutils literal notranslate"><span class="pre">exp(x)</span> <span class="pre">/</span> <span class="pre">(1</span> <span class="pre">+</span> <span class="pre">exp(x))</span></code>. Transforms any real number <code class="docutils literal notranslate"><span class="pre">x</span></code> to a value between 0 and 1 (a probability).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">logit</span></code>: Not directly available as a named function, use <code class="docutils literal notranslate"><span class="pre">log(p/(1-p))</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">probit(p)</span></code>: The probit function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iprobit(x)</span></code>: Inverse probit function. Equivalent to <code class="docutils literal notranslate"><span class="pre">phi(x)</span></code> (CDF of the standard normal distribution).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">iloglog(x)</span></code>: Inverse log-log link function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">icloglog(x)</span></code>: Inverse complementary log-log link function.</p></li>
</ul>
</li>
</ul>
<p><strong>Example (Logistic Regression):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>stparm(p = ilogit(A * time + B))  // &#39;p&#39; is a probability between 0 and 1
LL(Resp, Resp * log(p) + (1 - Resp) * log(1 - p))
</pre></div>
</div>
<p><strong>Keywords:</strong> link function, inverse link function, ilogit, logit, probit, iprobit, iloglog, icloglog, logistic regression, categorical data</p>
<p><strong>See also:</strong> <code class="docutils literal notranslate"><span class="pre">multi</span></code>, <code class="docutils literal notranslate"><span class="pre">LL</span></code>, Categorical Data, Ordinal Data, Logistic Regression</p>
</section>
<section id="if-and-ternary-operator">
<span id="nlme-if-and-ternary-operator"></span><h3>if and Ternary Operator<a class="headerlink" href="#if-and-ternary-operator" title="Link to this heading">¶</a></h3>
<p>Conditional logic allows different calculations or actions
based on variable values. PML provides <code class="docutils literal notranslate"><span class="pre">if/else</span></code> <em>within</em> <code class="docutils literal notranslate"><span class="pre">sequence</span></code>
blocks and the ternary operator (<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>) for expressions.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">if/else</span></code> <strong>(within</strong> <code class="docutils literal notranslate"><span class="pre">sequence</span></code> <strong>blocks ONLY):</strong></p>
<ul>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">sequence</span> <span class="pre">{</span> <span class="pre">if</span> <span class="pre">(condition)</span> <span class="pre">{</span> <span class="pre">&lt;statements&gt;</span> <span class="pre">}</span> <span class="pre">else</span> <span class="pre">{</span> <span class="pre">&lt;statements&gt;</span> <span class="pre">}</span> <span class="pre">}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">condition</span></code>: A logical expression (true or false). Use C++-style logical operators (<code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code>) within the condition.</p></li>
<li><p><em>Only</em> usable within <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks.</p></li>
</ul>
</li>
<li><p><strong>Restrictions</strong></p>
<ul>
<li><p>if/else could be used inside <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks only</p></li>
<li><p>The observed variable in the <code class="docutils literal notranslate"><span class="pre">LL</span></code> statement cannot be used
anywhere in the model outside of this statement.</p></li>
</ul>
</li>
<li><p><strong>Ternary Operator (for expressions):</strong></p>
<ul>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">condition</span> <span class="pre">?</span> <span class="pre">value_if_true</span> <span class="pre">:</span> <span class="pre">value_if_false</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">condition</span></code>: A logical expression. Use nested ternary operators
for complex conditions (cannot use <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">not</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_if_true</span></code>: Value if <code class="docutils literal notranslate"><span class="pre">condition</span></code> is true.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">value_if_false</span></code>: Value if <code class="docutils literal notranslate"><span class="pre">condition</span></code> is false.</p></li>
<li><p>Usable <em>anywhere</em> an expression is allowed (e.g., <code class="docutils literal notranslate"><span class="pre">stparm</span></code>, <code class="docutils literal notranslate"><span class="pre">deriv</span></code>, <code class="docutils literal notranslate"><span class="pre">observe</span></code>, <code class="docutils literal notranslate"><span class="pre">LL</span></code>).</p></li>
<li><p>For complex conditions (more than one <code class="docutils literal notranslate"><span class="pre">else</span></code>), nest ternary operators. You cannot use <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, and <code class="docutils literal notranslate"><span class="pre">not</span></code> keywords.
Use C++ style operators: <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">||</span></code> and <code class="docutils literal notranslate"><span class="pre">!</span></code>.</p></li>
</ul>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the only way to express conditional logic outside of a <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block.</p>
</div>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>// CORRECT - Ternary operator outside of sequence block
EHC = SINE &lt;= 0 ? 0 : SINE

// INCORRECT - if/else outside of sequence block
EHC = if (SINE &lt;= 0) 0 else SINE

sequence {
// CORRECT - if/else inside sequence block
if (Time &gt; 10)
{
  DoseRate = 0
  }
}
</pre></div>
</div>
<p><strong>Example (Ternary Operator):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>stparm(
  Cl = tvCl * exp(dClSex * (Sex == 1 ? 1 : 0) + nCl)  // Effect of Sex on Cl
)
</pre></div>
</div>
<p>This is equivalent to: If Sex equal to 1 then Cl = tvCl * exp(nClPeriod2 + nCl) otherwise Cl = tvCl * exp(nCl)</p>
<p><strong>Keywords:</strong> if, else, ternary operator, conditional logic, sequence</p>
<p><strong>See also:</strong> <code class="docutils literal notranslate"><span class="pre">sequence</span></code>, Expressions, Logical Operators</p>
</section>
<section id="logical-operators">
<h3>Logical Operators<a class="headerlink" href="#logical-operators" title="Link to this heading">¶</a></h3>
<p>Logical operators create logical expressions (conditions)
that evaluate to true or false. The allowed operators differ depending
on whether they are used inside or outside a <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block.</p>
<ul class="simple">
<li><p><strong>Comparison Operators:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">==</span></code>: Equal to</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">!=</span></code>: Not equal to</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;</span></code>: Greater than</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;</span></code>: Less than</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>: Greater than or equal to</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>: Less than or equal to</p></li>
</ul>
</li>
<li><p><strong>Logical Operators:</strong></p>
<ul>
<li><p><strong>Within</strong> <code class="docutils literal notranslate"><span class="pre">sequence</span></code> <strong>blocks:</strong> Use C++-style logical operators: <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> (and), <code class="docutils literal notranslate"><span class="pre">||</span></code> (or), <code class="docutils literal notranslate"><span class="pre">!</span></code> (not).</p></li>
<li><p><strong>Outside</strong> <code class="docutils literal notranslate"><span class="pre">sequence</span></code> <strong>blocks:</strong> Nested ternary operators (<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>) for conditional logic are preferred, but C++-style
logical operators are also permitted.</p></li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>sequence {
  if (Time &gt; 10 &amp;&amp; DoseRate &gt; 0) {  // Correct
    DoseRate = 0
  }
}

stparm(
  K21 = t &lt; 6 ? 0 : t &lt; 8 ? tvK21 : 0  // Correct: Nested ternary
)

stparm(
  Cl = tvCl * exp(dClSex * (Sex == 1) + nCl)  // Using == for comparison
)

stparm(
  K21 = t &gt;= 6 and t &lt;= 8 ? tvK21 : 0  // INCORRECT: Cannot use &#39;and&#39;
)
</pre></div>
</div>
<p><strong>Keywords:</strong> logical operators, comparison operators, ==, !=, &gt;, &lt;, &gt;=, &lt;=, and, or, not</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-if-and-ternary-operator"><span class="std std-ref">if and Ternary Operator</span></a>, <a class="mono reference internal" href="#nlme-sequence"><span class="std std-ref">sequence</span></a></p>
</section>
<section id="sleep">
<span id="nlme-sleep"></span><h3>sleep<a class="headerlink" href="#sleep" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">sleep</span></code> function, used <em>within</em> a <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block,
pauses execution for a specified duration, introducing time delays in
action code.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To pause the execution of a <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block.</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">sleep(duration)</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">duration</span></code>: Expression for the amount of time to sleep (in model
time units).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code> <strong>Block Only:</strong> <code class="docutils literal notranslate"><span class="pre">sleep</span></code> can <em>only</em> be used within a <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block.</p></li>
<li><p><strong>Relative Time:</strong> <code class="docutils literal notranslate"><span class="pre">duration</span></code> is <em>relative</em> to when <code class="docutils literal notranslate"><span class="pre">sleep</span></code> is
encountered, <em>not</em> absolute time.</p></li>
<li><p><strong>Stability:</strong> sleep statement should be used to ensure the stability
of the algorithms</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>sequence {
  sleep(5)     // Pause for 5 time units
  A1 = A1 + 10  // Add 10 to compartment A1 after the delay
}
</pre></div>
</div>
<p><strong>Keywords:</strong> sleep, sequence, time delay, action code</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-sequence"><span class="std std-ref">sequence</span></a>, Time Delays, Action Code</p>
</section>
<section id="statistical-distribution-functions">
<h3>Statistical Distribution Functions<a class="headerlink" href="#statistical-distribution-functions" title="Link to this heading">¶</a></h3>
<p>PML provides functions for calculating the PDF, CDF, log PDF, and log CDF of several common statistical distributions, often used within the <code class="docutils literal notranslate"><span class="pre">LL</span></code> statement.</p>
<ul class="simple">
<li><p><strong>Normal Distribution:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">lnorm(x,</span> <span class="pre">std)</span></code>: Logarithm of the PDF of a normal distribution
(mean 0, standard deviation <code class="docutils literal notranslate"><span class="pre">std</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lphi(x,</span> <span class="pre">std)</span></code>: Logarithm of the CDF of a normal distribution
(mean 0, standard deviation <code class="docutils literal notranslate"><span class="pre">std</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">phi(x)</span></code>: CDF of the <em>standard</em> normal distribution (mean 0,
standard deviation 1).</p></li>
</ul>
</li>
<li><p><strong>Weibull Distribution:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">dweibull(x,</span> <span class="pre">shape,</span> <span class="pre">scale)</span></code>: PDF.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ldweibull(x,</span> <span class="pre">shape,</span> <span class="pre">scale)</span></code>: Log PDF.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pweibull(x,</span> <span class="pre">shape,</span> <span class="pre">scale)</span></code>: CDF.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lpweibull(x,</span> <span class="pre">shape,</span> <span class="pre">scale)</span></code>: Log CDF.</p></li>
</ul>
</li>
<li><p><strong>Inverse Gaussian Distribution:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">dinvgauss(t,</span> <span class="pre">mean,</span> <span class="pre">shape)</span></code>: PDF.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ldinvgauss(t,</span> <span class="pre">mean,</span> <span class="pre">shape)</span></code>: Log PDF.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pinvgauss(t,</span> <span class="pre">mean,</span> <span class="pre">shape)</span></code>: CDF.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lpinvgauss(t,</span> <span class="pre">mean,</span> <span class="pre">shape)</span></code>: Log CDF.</p></li>
</ul>
</li>
<li><p><strong>Poisson Distribution:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">lpois(mean,</span> <span class="pre">n)</span></code>: Logarithm of the probability mass function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ppois(mean,</span> <span class="pre">n)</span></code>: Probability mass function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rpois(lambda)</span></code>: random number</p></li>
<li><p>unifToPoisson(mean, r): convert a uniform random number between 0
and 1 to a Poisson random number</p></li>
</ul>
</li>
<li><p><strong>Negative Binomial Distribution:</strong></p>
<ul>
<li><p>lnegbin_rp(r, p, y): logarithm of the probability mass function of
a negative binomial, distribution parameterized by r and p</p></li>
<li><p>megnin_rp(r, p): generate a random sample from a negative binomial
distribution parameterized by r and p</p></li>
<li><p>lnegbin(mean, beta, power, y): logarithm of the probability mass
function of a negative binomial distribution parameterized by
mean, beta (=log(alpha)), and power</p></li>
<li><p>pnegbin(mean, beta, power, y): probability mass function of a
negative binomial distribution parameterized by mean, beta (=
log(alpha)), and power</p></li>
<li><p>rnegbin(mean, beta, power): generate a random sample from a
negative binomial distribution parameterized by mean beta (=
log(alpha)), and power</p></li>
</ul>
</li>
</ul>
<p><strong>Example (using</strong> <code class="docutils literal notranslate"><span class="pre">lnorm</span></code> <strong>in an</strong> <code class="docutils literal notranslate"><span class="pre">LL</span></code> <strong>statement):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>LL(Obs, lnorm(Obs - Pred, ErrorSD))  // Custom log-likelihood for normal distribution
</pre></div>
</div>
<p><strong>Keywords:</strong> statistical distributions, probability density function,
PDF, cumulative distribution function, CDF, log-likelihood, lnorm, lphi,
phi, dweibull, ldweibull, pweibull, lpweibull, dinvgauss, ldinvgauss,
pinvgauss, lpinvgauss</p>
<p><strong>See also:</strong> Probability Distributions, <code class="docutils literal notranslate"><span class="pre">LL</span></code>, Likelihood</p>
</section>
</section>
<section id="additional-statements-and-features">
<h2>Additional Statements and Features<a class="headerlink" href="#additional-statements-and-features" title="Link to this heading">¶</a></h2>
<section id="secondary-parameters">
<h3>Secondary Parameters<a class="headerlink" href="#secondary-parameters" title="Link to this heading">¶</a></h3>
<p>Secondary parameters are quantities <strong>calculated</strong> from primary (structural) parameters, fixed effects, and other variables.
They are not directly estimated but are derived. They <strong>cannot</strong> depend directly on structural parameters.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To calculate and report derived quantities of interest (e.g., half-life, AUC, Cmax), <strong>after</strong> the main model fitting is complete.
<strong>These are not part of the core model dynamics.</strong></p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">secondary(parameterName</span> <span class="pre">=</span> <span class="pre">expression)</span></code></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">parameterName</span></code>: The name of the secondary parameter.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">expression</span></code>: Defines how to calculate <code class="docutils literal notranslate"><span class="pre">parameterName</span></code>. Can
include:</p>
<ul>
<li><p>Fixed effects (e.g., <code class="docutils literal notranslate"><span class="pre">tvV</span></code>, <code class="docutils literal notranslate"><span class="pre">tvCl</span></code>).</p></li>
<li><p>Other secondary parameters (defined <em>before</em> this one).</p></li>
<li><p>Mathematical operators and functions.</p></li>
<li><p>Covariates</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">idosevar</span></code>, <code class="docutils literal notranslate"><span class="pre">infdosevar</span></code>, <code class="docutils literal notranslate"><span class="pre">infratevar</span></code> variables</p></li>
</ul>
</li>
<li><p><strong>Cannot Include:</strong> Structural parameters (parameters defined with
<code class="docutils literal notranslate"><span class="pre">stparm</span></code>), random effects, or variables defined by top-level
assignment. Secondary parameters are functions of <em>fixed</em> effects,
and other derived quantities, <em>not</em> the individual-specific
parameter values or dynamic variables.</p></li>
</ul>
</li>
<li><p><strong>Calculation:</strong> Calculated once after all model fitting is completed.</p></li>
<li><p><strong>Multiple</strong> <code class="docutils literal notranslate"><span class="pre">secondary</span></code> <strong>statements:</strong> can be included.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>There is generally no direct equivalent to <code class="docutils literal notranslate"><span class="pre">secondary</span></code> parameters in standard NONMEM code.
The <code class="docutils literal notranslate"><span class="pre">secondary</span></code> statement in PML is a convenience for post-processing and reporting,
<strong>not</strong> for defining relationships within the core model. Do not translate simple assignments from NONMEM’s <code class="docutils literal notranslate"><span class="pre">$PK</span></code> or <code class="docutils literal notranslate"><span class="pre">$DES</span></code> blocks
into <code class="docutils literal notranslate"><span class="pre">secondary</span></code> statements.</p>
</div>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>stparm(Cl = tvCl * exp(nCl))
stparm(V  = tvV * exp(nV))
fixef(tvCl = c(,5,))
fixef(tvV = c(,50,))

secondary(
  Halflife = log(2) / (tvCl / tvV)  // Calculate half-life from fixed effects
)
</pre></div>
</div>
<p><strong>Keywords:</strong> secondary parameter, derived parameter, calculated parameter, secondary, fixed effects</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-stparm"><span class="std std-ref">stparm</span></a>, <a class="reference internal" href="#nlme-fixed-effects"><span class="std std-ref">Fixed Effects</span></a></p>
</section>
<section id="data-mapping-column-definitions">
<span id="nlme-data-mapping"></span><h3>Data Mapping (Column Definitions)<a class="headerlink" href="#data-mapping-column-definitions" title="Link to this heading">¶</a></h3>
<p>Data mapping links columns in your input dataset to variables and contexts within your PML model. This is done <em>outside</em> the PML code, using a column definition file or interface.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> To tell the execution engine how to interpret the data
in your input file.</p></li>
<li><p><strong>Column Definition File:</strong> A text file (or equivalent interface)
with mapping statements.</p></li>
<li><p><strong>Key Mapping Statements:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">id(columnName)</span></code>: Maps a column to the subject ID. Example: <code class="docutils literal notranslate"><span class="pre">id(SubjectID)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time(columnName)</span></code>: Maps a column to the time variable (<code class="docutils literal notranslate"><span class="pre">t</span></code>). Example: <code class="docutils literal notranslate"><span class="pre">time(Time)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">obs(observedVariable</span> <span class="pre">&lt;-</span> <span class="pre">columnName)</span></code>: Maps a column to an observed variable. Example: <code class="docutils literal notranslate"><span class="pre">obs(CObs</span> <span class="pre">&lt;-</span> <span class="pre">Conc)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">amt(columnName)</span></code>: Maps a column to the dose amount (with <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code>). Example: <code class="docutils literal notranslate"><span class="pre">amt(DoseAmt)</span></code>.</p>
<ul>
<li><p>Can map a single column containing <strong>both</strong> bolus and infusion amounts.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">rate(columnName)</span></code>: Maps a column to the infusion rate (with <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code>). Example: <code class="docutils literal notranslate"><span class="pre">rate(InfRate)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">covr(covariateName</span> <span class="pre">&lt;-</span> <span class="pre">columnName)</span></code>: Maps a column to a covariate (<code class="docutils literal notranslate"><span class="pre">covariate</span></code> or <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>). Example:
<code class="docutils literal notranslate"><span class="pre">covr(Weight</span> <span class="pre">&lt;-</span> <span class="pre">BW)</span></code>.</p>
<ul>
<li><p><strong>Categorical Covariates:</strong></p>
<ul>
<li><p>With labels: <code class="docutils literal notranslate"><span class="pre">covr(Sex</span> <span class="pre">&lt;-</span> <span class="pre">SexColumn(&quot;Male&quot;</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">&quot;Female&quot;</span> <span class="pre">=</span> <span class="pre">1))</span></code></p></li>
<li><p>Without labels: <code class="docutils literal notranslate"><span class="pre">covr(Sex</span> <span class="pre">&lt;-</span> <span class="pre">SexColumn())</span></code> (First unique value is the reference category).</p></li>
</ul>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">fcovr(covariateName</span> <span class="pre">&lt;-</span> <span class="pre">columnName)</span></code>: Same as <code class="docutils literal notranslate"><span class="pre">covr</span></code>, but for <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">censor(columnName)</span></code>: Maps a column to the BQL flag from <code class="docutils literal notranslate"><span class="pre">observe</span></code>. Example: <code class="docutils literal notranslate"><span class="pre">censor(CObsBQL)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">loq(columnName)</span></code>: Maps a column to provide lower limits of quantification. Example: <code class="docutils literal notranslate"><span class="pre">loq(LLOQ)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mvd(columnName)</span></code>: Maps a column to indicate missing data values for observations. Example: <code class="docutils literal notranslate"><span class="pre">mvd(MDV)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">evid(columnName)</span></code>: Maps a column to an event identifier. Example: <code class="docutils literal notranslate"><span class="pre">evid(EVID)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">addl(columnName,</span> <span class="pre">doseCycleDescription)</span></code>: Maps a column to indicate additional doses. Example: <code class="docutils literal notranslate"><span class="pre">addl(ADDL,</span> <span class="pre">24</span> <span class="pre">dt</span> <span class="pre">10</span> <span class="pre">bolus(A1))</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ii(columnName)</span></code>: Maps a column to the interdose interval. Often <em>derived</em> from <code class="docutils literal notranslate"><span class="pre">addl</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dose(doseVariable</span> <span class="pre">&lt;-</span> <span class="pre">columnName,</span> <span class="pre">cmt</span> <span class="pre">=</span> <span class="pre">compartmentNumber)</span></code>: <em>Conditional</em> mapping of doses. Maps <code class="docutils literal notranslate"><span class="pre">columnName</span></code> to
<code class="docutils literal notranslate"><span class="pre">doseVariable</span></code> <em>only when</em> <code class="docutils literal notranslate"><span class="pre">cmt</span></code> matches <code class="docutils literal notranslate"><span class="pre">compartmentNumber</span></code>. Essential for multiple dosepoints. Example: <code class="docutils literal notranslate"><span class="pre">dose(AaDose</span> <span class="pre">&lt;-</span> <span class="pre">AMT,</span> <span class="pre">cmt</span> <span class="pre">=</span> <span class="pre">1)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cmt(columnName)</span></code>: Maps a column specifying the compartment number (with conditional <code class="docutils literal notranslate"><span class="pre">dose</span></code>). Example: <code class="docutils literal notranslate"><span class="pre">cmt(CMT)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ss(ssColumnName,</span> <span class="pre">doseCycleDescription)</span></code>: Maps a column that indicates steady-state dosing.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">reset(resetColumnName=c(lowValue,</span> <span class="pre">highValue))</span></code>: Maps a column to reset time and compartments</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">date(dateColumnName[,</span> <span class="pre">formatString</span> <span class="pre">[,</span> <span class="pre">centuryBase]])</span></code>: maps date column</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dvid(columnName)</span></code>: Maps a column to an observation type identifier (multiple observation types in same data column).
Example: <code class="docutils literal notranslate"><span class="pre">dvid(TYPE)</span></code>. Used with conditional observation mapping.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">table(...)</span></code>: (Not for input, defines output tables).</p></li>
</ul>
</li>
<li><p><strong>Conditional Mapping:</strong> Use conditional logic in mappings to handle rows differently (e.g., based on <code class="docutils literal notranslate"><span class="pre">CMT</span></code>, <code class="docutils literal notranslate"><span class="pre">DVID</span></code>). Map the same data column to different variables, depending on context.</p></li>
</ul>
<p><strong>Example (Conceptual Column Mappings - PK/PD, Multiple Doses, BQL):</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">id</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span>
<span class="n">time</span><span class="p">(</span><span class="n">TIME</span><span class="p">)</span>
<span class="n">amt</span><span class="p">(</span><span class="n">AMT</span><span class="p">)</span>
<span class="n">addl</span><span class="p">(</span><span class="n">ADDL</span><span class="p">)</span>        <span class="o">//</span> <span class="n">Additional</span> <span class="n">doses</span>
<span class="n">ii</span><span class="p">(</span><span class="n">II</span><span class="p">)</span>            <span class="o">//</span> <span class="n">Interdose</span> <span class="n">interval</span>
<span class="n">mvd</span><span class="p">(</span><span class="n">MDV</span><span class="p">)</span>
<span class="n">evid</span><span class="p">(</span><span class="n">EVID</span><span class="p">)</span>
<span class="n">obs</span><span class="p">(</span><span class="n">CObs</span> <span class="o">&lt;-</span> <span class="n">DV</span><span class="p">)</span>    <span class="o">//</span> <span class="n">PK</span> <span class="n">observations</span>
<span class="n">obs</span><span class="p">(</span><span class="n">EObs</span> <span class="o">&lt;-</span> <span class="n">DV</span><span class="p">)</span>  <span class="o">//</span> <span class="n">PD</span> <span class="n">observations</span>
<span class="n">covr</span><span class="p">(</span><span class="n">Weight</span> <span class="o">&lt;-</span> <span class="n">WEIGHT</span><span class="p">)</span>
<span class="n">covr</span><span class="p">(</span><span class="n">Sex</span> <span class="o">&lt;-</span> <span class="n">SEX</span><span class="p">(</span><span class="s2">&quot;Male&quot;</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Female&quot;</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">censor</span><span class="p">(</span><span class="n">CObsBQL</span><span class="p">)</span>  <span class="o">//</span> <span class="n">BQL</span> <span class="n">flag</span> <span class="k">for</span> <span class="n">PK</span> <span class="n">observations</span>
<span class="n">loq</span><span class="p">(</span><span class="n">LOQ</span><span class="p">)</span>
<span class="n">dose</span><span class="p">(</span><span class="n">AaDose</span> <span class="o">&lt;-</span> <span class="n">AMT</span><span class="p">,</span> <span class="n">cmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>   <span class="o">//</span> <span class="n">Map</span> <span class="n">AMT</span> <span class="n">to</span> <span class="n">AaDose</span> <span class="n">when</span> <span class="n">CMT</span><span class="o">=</span><span class="mi">1</span> <span class="p">(</span><span class="n">bolus</span><span class="p">)</span>
<span class="n">dose</span><span class="p">(</span><span class="n">AaInfDose</span> <span class="o">&lt;-</span> <span class="n">AMT</span><span class="p">,</span> <span class="n">cmt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">Map</span> <span class="n">AMT</span> <span class="n">to</span> <span class="n">AaInfDose</span> <span class="n">when</span> <span class="n">CMT</span><span class="o">=</span><span class="mi">1</span> <span class="p">(</span><span class="n">infusion</span><span class="p">)</span>
<span class="n">rate</span><span class="p">(</span><span class="n">AaInfRate</span> <span class="o">&lt;-</span> <span class="n">RATE</span><span class="p">)</span>     <span class="o">//</span> <span class="n">Infusion</span> <span class="n">rate</span>
<span class="n">dvid</span><span class="p">(</span><span class="n">TYPE</span><span class="p">)</span> <span class="o">//</span> <span class="n">DVID</span> <span class="k">for</span> <span class="n">distinguishing</span> <span class="n">PK</span><span class="o">/</span><span class="n">PD</span> <span class="n">observations</span>
</pre></div>
</div>
<p><strong>Keywords:</strong> data mapping, column mapping, input data, dataset, id, time, obs, amt, evid, rate, covariate, censor, loq, dvid, dose, addl, ii, table, ss, reset, date, Input Data, Conditional Mapping</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-observe"><span class="std std-ref">observe</span></a>, <a class="mono reference internal" href="#nlme-dosepoint"><span class="std std-ref">dosepoint</span></a>, <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="reference internal" href="#nlme-bql-handling"><span class="std std-ref">BQL Handling</span></a></p>
</section>
<section id="sequence">
<span id="nlme-sequence"></span><h3>sequence<a class="headerlink" href="#sequence" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block allows for <em>sequential</em> execution of
statements, unlike the generally declarative nature of PML. Used for
initialization, time-dependent actions, and discontinuous events.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> Define statements executed in order, at specific times.</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">sequence</span> <span class="pre">{</span> <span class="pre">statements</span> <span class="pre">}</span></code></p></li>
<li><p><strong>Key Feature: Sequential Execution:</strong> Order of statements <em>matters</em>
within a <code class="docutils literal notranslate"><span class="pre">sequence</span></code> block.</p></li>
<li><p><strong>Statements Allowed Within sequence:</strong></p>
<ul>
<li><p>Assignment statements (for variables modifiable when the model is
stopped – integrator variables, <code class="docutils literal notranslate"><span class="pre">real</span></code>/<code class="docutils literal notranslate"><span class="pre">double</span></code> variables).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(test-expression)</span> <span class="pre">statement-or-block</span> <span class="pre">[else</span> <span class="pre">statement-or-block]</span></code>
(Conditional execution). Use ternary operator (<code class="docutils literal notranslate"><span class="pre">?</span> <span class="pre">:</span></code>) <em>within</em>
expressions, <em>not</em> <code class="docutils literal notranslate"><span class="pre">if/else</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">(test-expression)</span> <span class="pre">statement-or-block</span></code> (Looping)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep(duration-expression)</span></code> (Pauses execution)</p></li>
<li><p>Function calls</p></li>
</ul>
</li>
<li><p><strong>Execution Timing:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks start <em>before</em> model simulation (at time 0).</p></li>
<li><p>Continue until <code class="docutils literal notranslate"><span class="pre">sleep</span></code> or end of block.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sleep</span></code> pauses, resuming at the future time.</p></li>
</ul>
</li>
<li><p><strong>Multiple</strong> <code class="docutils literal notranslate"><span class="pre">sequence</span></code> <strong>statements</strong> can be in a model, and they are executed as if in parallel.</p></li>
<li><p><strong>Reset:</strong> <code class="docutils literal notranslate"><span class="pre">sequence</span></code> statement(s) are restarted when a reset is encountered in the data</p></li>
<li><p><strong>Restrictions:</strong></p>
<ul>
<li><p>It is not strongly not recommended to modify inside <code class="docutils literal notranslate"><span class="pre">sequence</span></code>
fixed effects, random effects, residual erros, structural
parameters. It is impossible to modify observable variables.
<strong>Example (Initializing Compartments):</strong></p></li>
</ul>
</li>
</ul>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>sequence {
  A1 = 100  // Initialize A1 to 100 at time 0
  A2 = 0    // Initialize A2 to 0 at time 0
}
</pre></div>
</div>
<p><strong>Example (Time-Dependent Action):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>sequence {
  sleep(5)        // Wait 5 time units
  DoseRate = 0   // Turn off an infusion
}
</pre></div>
</div>
<p><strong>Example (Loop and Conditional):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>real(i)
sequence {
  i = 0
  while (i &lt; 10) {
    if (Concentration &lt; Threshold) {
      DoseRate = HighRate
    } else {
      DoseRate = LowRate
    }
    sleep(1)
    i = i + 1
  }
}
</pre></div>
</div>
<p><strong>Keywords:</strong> sequence, action code, sequential execution, sleep, if,
else, while, initialization, time-dependent actions</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure-statements"><span class="std std-ref">Statements</span></a>, <a class="reference internal" href="#nlme-model-structure-blocks"><span class="std std-ref">Blocks</span></a>, <a class="mono reference internal" href="#nlme-sleep"><span class="std std-ref">sleep</span></a>, <a class="reference internal" href="#nlme-if-and-ternary-operator"><span class="std std-ref">if and Ternary Operator</span></a>, <a class="mono reference internal" href="#nlme-real"><span class="std std-ref">real</span></a></p>
</section>
<section id="real-and-double">
<span id="nlme-real"></span><h3>real and double<a class="headerlink" href="#real-and-double" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">real</span></code> and <code class="docutils literal notranslate"><span class="pre">double</span></code> are synonyms, declaring variables
as double-precision floating-point numbers <em>modifiable</em> within
<code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks.</p>
<ul class="simple">
<li><p><strong>Purpose:</strong> Declare variables to be modified in <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks.</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">real(variableName1,</span> <span class="pre">variableName2,</span> <span class="pre">...)</span></code> or <code class="docutils literal notranslate"><span class="pre">double(variableName1,</span> <span class="pre">variableName2,</span> <span class="pre">...)</span></code></p></li>
<li><p><strong>Double Precision:</strong> <code class="docutils literal notranslate"><span class="pre">real</span></code>/<code class="docutils literal notranslate"><span class="pre">double</span></code> variables are double-precision.</p></li>
<li><p><strong>Modifiable in sequence:</strong> Can be assigned new values <em>within</em> <code class="docutils literal notranslate"><span class="pre">sequence</span></code> blocks (unlike top-level assignments).</p></li>
</ul>
<p><strong>Example:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>real(Counter, Flag)  // Declare Counter and Flag

sequence {
  Counter = 0
  while (Counter &lt; 10) {
    Counter = Counter + 1
    sleep(1)
  }
  Flag = if (Concentration &gt; Threshold) 1 else 0 //use ternary operator
}
</pre></div>
</div>
<p><strong>Keywords:</strong> real, double, variable declaration, sequence, modifiable variable</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure-variables"><span class="std std-ref">Variables</span></a>, <a class="mono reference internal" href="#nlme-sequence"><span class="std std-ref">sequence</span></a>, <a class="reference internal" href="#nlme-model-structure-assignment-statements"><span class="std std-ref">Assignment Statements</span></a></p>
</section>
</section>
<section id="model-generation-guidelines">
<h2>Model Generation Guidelines<a class="headerlink" href="#model-generation-guidelines" title="Link to this heading">¶</a></h2>
<section id="id1">
<h3>Model Generation Guidelines<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<p>This checklist provides best practices and common pitfalls
for generating correct PML models. It covers statement ordering,
parameter definition, error models, covariate incorporation, and
built-in functions, helping to avoid mistakes and improve
identifiability.</p>
<ol class="arabic">
<li><p><strong>Statement Ordering (Recommended Order):</strong></p>
<ul class="simple">
<li><p><strong>Covariate Declarations:</strong> <code class="docutils literal notranslate"><span class="pre">covariate</span></code>, <code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>, <code class="docutils literal notranslate"><span class="pre">interpolate</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> and <code class="docutils literal notranslate"><span class="pre">delayInfCpt</span></code>: Define dosing. <em>Before</em> <code class="docutils literal notranslate"><span class="pre">deriv</span></code> referencing the dosed compartment.</p></li>
<li><p><strong>Concentration Calculation:</strong> E.g., <code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">A1</span> <span class="pre">/</span> <span class="pre">V</span></code>. <em>Before</em> <code class="docutils literal notranslate"><span class="pre">deriv</span></code> using <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">deriv</span></code>: Define differential equations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code>: Define error variables (and their <em>numeric</em> standard deviations).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">observe</span></code>: Link predictions to observations, specify error model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stparm</span></code>: Define structural parameters. <em>After</em> covariate declarations, <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code>, and calculations they depend on.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fixef</span></code>: Define fixed effects (population parameters).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ranef</span></code>: Define random effects (inter-individual variability).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">secondary</span></code>: Define secondary (derived) parameters.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sequence</span></code>: For initialization (beginning) or time-dependent actions.</p></li>
</ul>
</li>
<li><p><strong>Structural Parameter Definition (stparm):</strong></p>
<ul class="simple">
<li><p><strong>Common Styles:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Product</span> <span class="pre">*</span> <span class="pre">exp(eta)</span></code>: <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">tvParameter</span> <span class="pre">*</span> <span class="pre">exp(nParameter)</span></code> (Log-normal - for positive-only parameters like V, Cl, Ka).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sum</span> <span class="pre">*</span> <span class="pre">exp(eta)</span></code>: <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">(tvParameter</span> <span class="pre">+</span> <span class="pre">covariate_effects)</span> <span class="pre">*</span> <span class="pre">exp(nParameter)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exp(Sum</span> <span class="pre">+</span> <span class="pre">eta)</span></code>: <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">exp(tvParameter</span> <span class="pre">+</span> <span class="pre">covariate_effects</span> <span class="pre">+</span> <span class="pre">nParameter)</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ilogit(Sum</span> <span class="pre">+</span> <span class="pre">eta)</span></code>: <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">ilogit(tvParameter</span> <span class="pre">+</span> <span class="pre">covariate_effects</span> <span class="pre">+</span> <span class="pre">nParameter)</span></code>
(For parameters between 0 and 1, like bioavailability).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Sum</span> <span class="pre">+</span> <span class="pre">eta</span></code>: <code class="docutils literal notranslate"><span class="pre">parameter</span> <span class="pre">=</span> <span class="pre">tvParameter</span> <span class="pre">+</span> <span class="pre">covariate_effects</span> <span class="pre">+</span> <span class="pre">nParameter</span></code>
(Normal - for parameters that can be positive or negative, like E0, Emax).</p></li>
</ul>
</li>
<li><p><strong>Choosing the Right Style:</strong></p>
<ul>
<li><p><strong>Positive-Only (V, Cl, Ka, etc.):</strong> <code class="docutils literal notranslate"><span class="pre">Product</span> <span class="pre">*</span> <span class="pre">exp(eta)</span></code> is generally preferred.</p></li>
<li><p><strong>Positive or Negative (E0, Emax, etc.):</strong> <code class="docutils literal notranslate"><span class="pre">Sum</span> <span class="pre">+</span> <span class="pre">eta</span></code> is appropriate.</p></li>
<li><p><strong>Between 0 and 1 (Bioavailability):</strong> <code class="docutils literal notranslate"><span class="pre">ilogit(Sum</span> <span class="pre">+</span> <span class="pre">eta)</span></code> is ideal.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">stparm</span></code> <strong>Restrictions:</strong> Within <code class="docutils literal notranslate"><span class="pre">stparm</span></code>, <em>only</em> use:</p>
<ul>
<li><p>Fixed effects (typically <code class="docutils literal notranslate"><span class="pre">tv</span></code> prefix).</p></li>
<li><p>Random effects (typically <code class="docutils literal notranslate"><span class="pre">n</span></code> prefix).</p></li>
<li><p>Declared covariates.</p></li>
<li><p>Mathematical operators and functions.</p></li>
<li><p><em>Cannot</em> use variables defined by assignment (e.g.,
<code class="docutils literal notranslate"><span class="pre">C</span> <span class="pre">=</span> <span class="pre">A1</span> <span class="pre">/</span> <span class="pre">V</span></code>).</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Covariate Incorporation:</strong></p>
<ul>
<li><p><strong>Declaration:</strong> Covariates <em>must</em> be declared (<code class="docutils literal notranslate"><span class="pre">covariate</span></code>,
<code class="docutils literal notranslate"><span class="pre">fcovariate</span></code>, or <code class="docutils literal notranslate"><span class="pre">interpolate</span></code>).</p></li>
<li><p><strong>Centering (Continuous Covariates):</strong> Improves stability and
reduces correlation.</p>
<ul class="simple">
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">(CovariateName</span> <span class="pre">/</span> <span class="pre">CenterValue)</span></code> (multiplicative)
or <code class="docutils literal notranslate"><span class="pre">(CovariateName</span> <span class="pre">-</span> <span class="pre">CenterValue)</span></code> (additive).</p></li>
<li><p><strong>Center Value:</strong> Mean, median, or clinically relevant value.</p></li>
</ul>
</li>
<li><p><strong>Categorical Covariates:</strong> Use
<code class="docutils literal notranslate"><span class="pre">(CovariateName</span> <span class="pre">==</span> <span class="pre">CategoryValue)</span></code> in <code class="docutils literal notranslate"><span class="pre">stparm</span></code>. The first
category is the reference. <em>Mapping is done in the column
definition file.</em></p></li>
<li><p><strong>Examples (stparm Styles with Covariates):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span># Product * exp(eta) (most common for positive parameters)
stparm(V = tvV * (Weight / 70)^dVdWt * exp(nV))  # Allometric scaling
stparm(Cl = tvCl * exp(dCldSex * (Sex == 1)) * exp(nCl)) # Sex effect

# Sum * exp(eta)
stparm(V = (tvV + dVdWt * (Weight - 70)) * exp(nV))

# exp(Sum + eta)
stparm(V = exp(tvV + dVdWt * (Weight - 70) + nV))

# ilogit(Sum + eta) (for parameters between 0 and 1)
stparm(F = ilogit(tvF + dFdWt * (Weight - 70) + nF))

# Sum + eta (for parameters that can be positive or negative)
stparm(E0 = tvE0 + dE0dWt * (Weight - 70) + nE0)

fcovariate(Weight)
fcovariate(Sex()) #categorical covariate
</pre></div>
</div>
</li>
</ul>
</li>
<li><p><strong>Error Model Specification:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">error</span></code>: Define error variables and their <em>numeric</em> standard deviations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">observe</span></code>: Link predictions to observations, specify error model (additive, proportional, combined, power, log-additive). Includes <em>one</em> error variable.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LL</span></code>: For custom likelihoods.</p></li>
<li><p>Use prescribed error variable names (like <code class="docutils literal notranslate"><span class="pre">CEps</span></code>)</p></li>
<li><p>Select an error model appropriate for your data.</p></li>
<li><p>“<strong>Standard Deviation vs. Variance:</strong> Ensure the value provided in the <code class="docutils literal notranslate"><span class="pre">error</span></code> statement is the <em>standard deviation</em>, not the
variance. If translating from NONMEM, remember to take the square root of the <code class="docutils literal notranslate"><span class="pre">$SIGMA</span></code> value (if it represents variance).”</p></li>
</ul>
</li>
<li><p><strong>Initialization:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">deriv</span></code> compartments are initialized to 0. <code class="docutils literal notranslate"><span class="pre">sequence</span></code>
overrides this.</p></li>
<li><p>Only <code class="docutils literal notranslate"><span class="pre">real</span></code>/<code class="docutils literal notranslate"><span class="pre">double</span></code>, integrator, and <code class="docutils literal notranslate"><span class="pre">urinecpt</span></code> variables
are modifiable in <code class="docutils literal notranslate"><span class="pre">sequence</span></code>.</p></li>
<li><p>Do not include explicit compartment initializations within
sequence blocks unless specifically required</p></li>
</ul>
</li>
<li><p><strong>Use of Built-In Functions:</strong></p>
<ul class="simple">
<li><p>Use functions for clarity and efficiency (e.g., <code class="docutils literal notranslate"><span class="pre">exp</span></code>, <code class="docutils literal notranslate"><span class="pre">log</span></code>,
<code class="docutils literal notranslate"><span class="pre">sqrt</span></code>, <code class="docutils literal notranslate"><span class="pre">ilogit</span></code>, <code class="docutils literal notranslate"><span class="pre">phi</span></code>, <code class="docutils literal notranslate"><span class="pre">lnorm</span></code>).</p></li>
</ul>
</li>
<li><p><strong>Review and Validation:</strong></p>
<ul class="simple">
<li><p><strong>Syntax Check:</strong> Double-check syntax.</p></li>
<li><p><strong>Simulation Testing:</strong> Validate by simulating scenarios.</p></li>
<li><p><strong>Parameter Estimates and SEs:</strong> Check for reasonableness. Large
values or high correlations can indicate problems.</p></li>
<li><p><strong>Documentation:</strong> Include comments.</p></li>
</ul>
</li>
<li><p><strong>Identifiability:</strong></p>
<ul class="simple">
<li><p>Be aware of <em>identifiability</em>. Can parameters be uniquely
estimated? Overparameterization can lead to non-identifiability.</p></li>
</ul>
</li>
</ol>
<p><strong>Example (Guideline Summary):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
  fcovariate(Weight)  # Declare covariate early
  fcovariate(Sex())    # Declare categorical covariate

  dosepoint(Aa, tlag = Tlag)  # Dosepoint (with structural lag time)
  C = A1 / V                # Define concentration *before* using it

  deriv(Aa = -Ka * Aa)      # Absorption compartment
  deriv(A1 = Ka * Aa - Cl * C - Cl2 * (C - C2) - Cl3 * (C - C3))  # Central
  deriv(A2 = Cl2 * (C - C2))                                    # Peripheral 2
  deriv(A3 = Cl3 * (C - C3))                                    # Peripheral 3
  C2 = A2/V2
  C3 = A3/V3

  error(CEps = 0.02)       # Numeric SD value!
  observe(CObs = C * (1 + CEps))  # Proportional error

  # Structural parameters (log-normal, with covariate effects)
  stparm(
    Ka   = tvKa * exp(nKa),
    V    = tvV * (Weight / 70)^dVdWt * exp(nV),         # Allometric scaling
    Cl   = tvCl * exp(dCldSex * (Sex == 1)) * exp(nCl),  # Sex effect
    Cl2  = tvCl2 * exp(nCl2),
    V2   = tvV2 * exp(nV2),
    Cl3  = tvCl3 * exp(nCl3),
    V3   = tvV3 * exp(nV3),
    Tlag = tvTlag * exp(nTlag)
  )

  # Fixed effects
  fixef(
    tvKa   = c(, 1, ),
    tvV    = c(, 50, ),
    tvCl   = c(, 5, ),
    tvCl2  = c(, 2, ),
    tvV2   = c(, 30, ),
    tvCl3  = c(, 1, ),
    tvV3   = c(, 20, ),
    tvTlag = c(, 0.5, ),
    dVdWt  = c(, 0.75, ),  # Fixed effect for Weight on V
    dCldSex = c(, 0, )     # Fixed effect for Sex on Cl
  )

  # Random effects
    ranef(diag(nV, nCl, nCl2, nV2, nCl3, nV3, nKa, nTlag) =
      c(0.09, 0.04, 0.04, 0.09, 0.04, 0.09, 0.04, 0.01)
  )
}
</pre></div>
</div>
<p><strong>Keywords:</strong> best practices, checklist, troubleshooting, model generation, PML, common pitfalls, validation, syntax, ordering,
parameterization, structural parameters, covariates, centering, error models</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-model-structure"><span class="std std-ref">PML Model Structure</span></a>, <a class="reference internal" href="#nlme-parameter-declarations"><span class="std std-ref">Parameter Declarations</span></a>, <a class="reference internal" href="#nlme-covariates"><span class="std std-ref">Covariates</span></a>, <a class="reference internal" href="#nlme-structural-model-definition"><span class="std std-ref">Structural Model Definition</span></a>, <a class="reference internal" href="#nlme-observation-and-error-models"><span class="std std-ref">Observation and Error Models</span></a>, <a class="reference internal" href="#nlme-delays"><span class="std std-ref">Delays</span></a>, <a class="reference internal" href="#nlme-built-in-functions"><span class="std std-ref">Built-In Functions</span></a>, <a class="reference internal" href="#nlme-data-mapping"><span class="std std-ref">Data Mapping</span></a></p>
</section>
</section>
<section id="modeling-complex-absorption-schemes">
<span id="nlme-modeling-complex-absorption-schemes"></span><h2>Modeling Complex Absorption Schemes<a class="headerlink" href="#modeling-complex-absorption-schemes" title="Link to this heading">¶</a></h2>
<p>Demonstrates how to combine multiple <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code>
statements and their options (<code class="docutils literal notranslate"><span class="pre">bioavail</span></code>, <code class="docutils literal notranslate"><span class="pre">tlag</span></code>, <code class="docutils literal notranslate"><span class="pre">duration</span></code>) to
model formulations with complex absorption kinetics, such as
simultaneous or sequential processes.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statement is highly flexible. By using multiple
<code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statements, you can model complex drug delivery systems
where a single dose (<code class="docutils literal notranslate"><span class="pre">AMT</span></code> from the data) is split into different
pathways or scheduled to occur sequentially.</p>
<section id="a-simultaneous-parallel-absorption-zero-order-and-first-order">
<span id="id2"></span><h3>A. Simultaneous (Parallel) Absorption (Zero-Order and First-Order)<a class="headerlink" href="#a-simultaneous-parallel-absorption-zero-order-and-first-order" title="Link to this heading">¶</a></h3>
<p>This pattern models a formulation with both immediate and sustained
release components that begin absorbing at the same time. A single dose
is split between a first-order and a zero-order process using a
fractional bioavailability parameter (<code class="docutils literal notranslate"><span class="pre">Fr</span></code>).</p>
<ul class="simple">
<li><p><strong>Key Concept:</strong> Two <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statements are used. One
(<code class="docutils literal notranslate"><span class="pre">dosepoint(Aa,</span> <span class="pre">bioavail</span> <span class="pre">=</span> <span class="pre">Fr)</span></code>) directs a fraction of the dose to
a first-order process. The other
(<code class="docutils literal notranslate"><span class="pre">dosepoint(A1,</span> <span class="pre">bioavail</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">Fr,</span> <span class="pre">duration</span> <span class="pre">=</span> <span class="pre">Dur)</span></code>) directs the
remaining fraction to a zero-order process.</p></li>
</ul>
<p><strong>Example Code (Simultaneous ZO/FO):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
    # PARALLEL PATHWAYS:
    # 1. First-order absorption for fraction &#39;Fr&#39;.
    dosepoint(Aa, bioavail = Fr)
    # 2. Zero-order absorption for fraction &#39;(1 - Fr)&#39; over duration &#39;Dur&#39;.
    dosepoint(A1, bioavail = 1 - Fr, duration = Dur)

    # Model structure
    C = A1 / V
    deriv(Aa = -Ka * Aa)
    deriv(A1 = Ka * Aa - Cl * C)

    # ... observe/error statements ...

    # Structural parameters
    stparm(Fr = ilogit(tvFr_logit + nFr_logit)) // Fraction for 1st-order
    stparm(Dur = tvDur * exp(nDur)) // Duration for 0-order
    # ... stparm for Cl, V, Ka ...

    # ... fixef/ranef statements ...
}
</pre></div>
</div>
</section>
<section id="b-sequential-absorption-zero-order-followed-by-first-order-zofo">
<span id="id3"></span><h3>B. Sequential Absorption (Zero-Order followed by First-Order - ZOFO)<a class="headerlink" href="#b-sequential-absorption-zero-order-followed-by-first-order-zofo" title="Link to this heading">¶</a></h3>
<p>This pattern models a formulation where an initial zero-order absorption
phase is immediately followed by a first-order absorption phase.</p>
<ul class="simple">
<li><p><strong>Key Concept:</strong> The sequence is created by using the same parameter
(<code class="docutils literal notranslate"><span class="pre">D</span></code> in this example) to define the <code class="docutils literal notranslate"><span class="pre">duration</span></code> of the zero-order
process and the <code class="docutils literal notranslate"><span class="pre">tlag</span></code> (time lag) of the first-order process. This
elegantly ensures the second process begins precisely when the first
one ends. This method is compatible with closed-form (<code class="docutils literal notranslate"><span class="pre">cfMicro</span></code>)
solutions.</p></li>
</ul>
<p><strong>Example Code (Sequential ZOFO):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
    # This model uses cfMicro because the time-dependency is handled by
    # the event scheduler (dosepoint), not by changing the ODEs themselves.
    cfMicro(A1, Cl / V, first = (Aa = Ka))
    C = A1 / V

    # SEQUENTIAL PATHWAYS:
    # 1. First-Order Pathway:
    # A fraction &#39;Fr&#39; of the dose is sent to the absorption depot &#39;Aa&#39;,
    # but its absorption is DELAYED by &#39;D&#39; time units.
    dosepoint(Aa, tlag = D, bioavail = Fr)

    # 2. Zero-Order Pathway:
    # The remaining fraction &#39;(1-Fr)&#39; is absorbed into the central
    # compartment &#39;A1&#39; over a DURATION of &#39;D&#39; time units, starting at time 0.
    dosepoint(A1, bioavail = 1 - Fr, duration = D)

    # Define the fraction &#39;Fr&#39; to be absorbed first-order (after the lag)
    stparm(Fr = ilogit(tvFr_logit + nFr_logit))
    fixef(tvFr_logit = c(, 0, ))
    ranef(diag(nFr_logit) = c(0.09))

    # Define the duration/tlag parameter &#39;D&#39;
    stparm(D = tvD * exp(nD))
    fixef(tvD = c(, 1, ))
    ranef(diag(nD) = c(0.09))

    # ... observe/error statements ...
    # ... stparm, fixef, ranef for Cl, V, Ka ...
}
</pre></div>
</div>
</section>
<section id="c-splitting-a-single-dose-into-different-administration-profiles-e-g-bolus-infusion">
<span id="c-splitting-a-single-dose-into-different-administration-profiles-eg-bolus-infusion"></span><h3>C. Splitting a Single Dose into Different Administration Profiles (e.g., Bolus + Infusion)<a class="headerlink" href="#c-splitting-a-single-dose-into-different-administration-profiles-e-g-bolus-infusion" title="Link to this heading">¶</a></h3>
<p>This pattern is used for a single dose amount that is administered in
two different ways simultaneously (e.g., a formulation that gives an
initial bolus effect while also starting a slow-release infusion).</p>
<ul class="simple">
<li><p><strong>Key Concept:</strong> This is achieved by using <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> and
<code class="docutils literal notranslate"><span class="pre">dosepoint2</span></code> on the <em>same compartment</em>. The crucial <code class="docutils literal notranslate"><span class="pre">split</span></code>
argument is added to the first <code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statement. This allows a
single dose amount from one column in the data (e.g., <code class="docutils literal notranslate"><span class="pre">AMT</span></code>) to be
divided between the two statements using their respective
<code class="docutils literal notranslate"><span class="pre">bioavail</span></code> options.</p></li>
</ul>
<p><strong>Example (50% Bolus, 50% Infusion over 3 time units):</strong></p>
<p>This model takes a single dose amount and administers 50% of it as an
instantaneous bolus into <code class="docutils literal notranslate"><span class="pre">Aa</span></code>, while simultaneously starting a 3-hour
infusion of the other 50% into the same <code class="docutils literal notranslate"><span class="pre">Aa</span></code> compartment.</p>
<p><strong>PML Code:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test(){
    # Define the central compartment and concentration
    deriv(A1 = - (Cl * C) + (Aa * Ka))
    deriv(Aa = - (Aa * Ka))
    C = A1 / V

    # DOSE SPLITTING:
    # 1. Define the bolus part. &#39;bioavail=(.5)&#39; takes 50% of the dose.
    #    &#39;split&#39; is ESSENTIAL to allow the same data column to be used for dosepoint2.
    dosepoint(Aa, bioavail = (.5), split)

    # 2. Define the infusion part on the same compartment &#39;Aa&#39;.
    #    &#39;bioavail=(.5)&#39; takes the other 50% of the dose.
    #    &#39;duration=(3)&#39; defines the zero-order infusion time.
    dosepoint2(Aa, bioavail = (.5), duration = (3))

    # ... observe/error and parameter definition statements ...
    error(CEps = 30)
    observe(CObs = C + CEps)
    stparm(V = tvV * exp(nV))
    stparm(Cl = tvCl * exp(nCl))
    stparm(Ka = tvKa * exp(nKa))
    # ... fixef/ranef statements ...
}
</pre></div>
</div>
<p><strong>Corresponding Column Definition Mapping:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Because &#39;split&#39; is used, both dose() and dose2() can map to &quot;AMT&quot;.</span>
<span class="n">dose</span><span class="p">(</span><span class="n">Aa</span><span class="o">&lt;-</span><span class="s2">&quot;AMT&quot;</span><span class="p">)</span>
<span class="n">dose2</span><span class="p">(</span><span class="n">Aa</span><span class="o">&lt;-</span><span class="s2">&quot;AMT&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="d-parallel-absorption-with-independent-lag-times">
<span id="id4"></span><h3>D. Parallel Absorption with Independent Lag Times<a class="headerlink" href="#d-parallel-absorption-with-independent-lag-times" title="Link to this heading">¶</a></h3>
<p>For maximum flexibility, especially with complex formulations, you can
assign independent lag times to each parallel absorption pathway. This
allows for modeling scenarios where two different release mechanisms
from a single dose not only have different profiles (e.g., zero-order
vs. first-order) but also start at different times.</p>
<ul class="simple">
<li><p><strong>Key Concept:</strong> Use a separate <code class="docutils literal notranslate"><span class="pre">tlag</span></code> argument in each
<code class="docutils literal notranslate"><span class="pre">dosepoint</span></code> statement. Each <code class="docutils literal notranslate"><span class="pre">tlag</span></code> can be linked to a different
structural parameter, allowing them to be estimated independently.</p></li>
</ul>
<p><strong>Example (Simultaneous ZOFO with Independent Lags):</strong> This model splits
a dose into a first-order pathway and a zero-order pathway, where each
can start after its own unique delay.</p>
<p><strong>PML Code Snippet (Focus on dosepoint):</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span># 1. First-Order Pathway with its own lag time &#39;Tlag_FO&#39;
dosepoint(Aa, bioavail = Fr_FO, tlag = Tlag_FO)

# 2. Zero-Order Pathway with its own lag time &#39;Tlag_ZO&#39;
dosepoint(A1, bioavail = 1 - Fr_FO, duration = Dur_ZO, tlag = Tlag_ZO)

# ... parameter definitions for Tlag_FO and Tlag_ZO would be separate ...
stparm(Tlag_FO = tvTlag_FO * exp(nTlag_FO))
stparm(Tlag_ZO = tvTlag_ZO * exp(nTlag_ZO))
</pre></div>
</div>
<p><strong>Keywords:</strong> absorption, parallel absorption, sequential absorption, dose splitting, dual absorption, ZOFO, lag time, tlag, duration, bioavail</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-dosepoint"><span class="std std-ref">dosepoint</span></a>, <a class="mono reference internal" href="#nlme-split"><span class="std std-ref">split</span></a>, <a class="mono reference internal" href="#nlme-dosepoint"><span class="std std-ref">bioavail</span></a>, <a class="mono reference internal" href="#nlme-dosepoint"><span class="std std-ref">duration</span></a>, <a class="mono reference internal" href="#nlme-dosepoint"><span class="std std-ref">tlag</span></a></p>
</section>
<section id="modeling-multiple-elimination-pathways">
<h3>Modeling Multiple Elimination Pathways<a class="headerlink" href="#modeling-multiple-elimination-pathways" title="Link to this heading">¶</a></h3>
<p>Describes how to model drugs that are cleared by multiple
simultaneous mechanisms (e.g., a mix of linear and saturable pathways)
by summing their individual rate equations within the <code class="docutils literal notranslate"><span class="pre">deriv</span></code>
statement.</p>
<p>Pharmacokinetic models in PML are modular. If a drug is eliminated by
more than one process, the total rate of elimination is simply the sum
of the rates of each individual pathway. This is implemented by
subtracting each elimination rate term within the <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statement
for the central compartment.</p>
<p><strong>Total Elimination Rate = (Rate of Pathway 1) + (Rate of Pathway 2) +
…</strong></p>
<p><strong>Example: Mixed Linear and Saturable (Hill-Type) Elimination</strong></p>
<p>A common scenario is a drug cleared by both a first-order (linear)
process and a capacity-limited (saturable) process.</p>
<ul class="simple">
<li><p><strong>Linear Pathway Rate:</strong> <code class="docutils literal notranslate"><span class="pre">Cl</span> <span class="pre">*</span> <span class="pre">C</span></code></p></li>
<li><p><strong>Saturable Pathway Rate (with Hill):</strong>
<code class="docutils literal notranslate"><span class="pre">(Vmax</span> <span class="pre">*</span> <span class="pre">C^h)</span> <span class="pre">/</span> <span class="pre">(Km^h</span> <span class="pre">+</span> <span class="pre">C^h)</span></code></p></li>
</ul>
<p><strong>Implementation in</strong> <code class="docutils literal notranslate"><span class="pre">deriv</span></code> <strong>Statement:</strong> The <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statement for
the central compartment (<code class="docutils literal notranslate"><span class="pre">A1</span></code>) would include the drug input minus both
elimination terms.</p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>deriv(
    A1 = (INPUT) - (Cl * C) - (Vmax * C^h) / (Km^h + C^h)
)
</pre></div>
</div>
<p><strong>Full Example Model (from previous interaction):</strong> This code shows the
principle in a complex model that combines parallel absorption with
mixed-order elimination. Note the two separate subtraction terms in the
<code class="docutils literal notranslate"><span class="pre">deriv(A1</span> <span class="pre">=</span> <span class="pre">...)</span></code> line.</p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>test() {
    # Parallel absorption with independent lag times
    dosepoint(Aa, bioavail = Fr_FO, tlag = Tlag_FO)
    dosepoint(A1, bioavail = 1 - Fr_FO, duration = Dur_ZO, tlag = Tlag_ZO)

    C = A1 / V
    deriv(Aa = -Ka * Aa)
    deriv(
        # The two elimination pathways are summed here by subtracting each term
        A1 = (Ka * Aa) - ( (Cl * C) + (Vmax * C^h) / (Km^h + C^h) )
    )

    # ... observe/error statements ...

    # Structural parameters including Cl, Vmax, Km, and h
    stparm(Cl   = tvCl   * exp(nCl))       // Linear clearance
    stparm(Vmax = tvVmax * exp(nVmax))     // Saturable Vmax
    stparm(Km   = tvKm   * exp(nKm))       // Saturable Km
    stparm(h    = tvh    * exp(nh))        // Hill coefficient
    # ... other stparm, fixef, ranef statements ...
}
</pre></div>
</div>
<p><strong>Keywords:</strong> elimination, clearance, Michaelis-Menten, mixed-order, parallel pathways, deriv, Vmax, Km, Hill</p>
<p><strong>See also:</strong> <a class="mono reference internal" href="#nlme-deriv"><span class="std std-ref">deriv</span></a>, <a class="reference internal" href="#nlme-compartment-models"><span class="std std-ref">Compartment Models</span></a>, Michaelis-Menten Kinetics</p>
</section>
</section>
<section id="introduction-to-metamodels">
<h2>Introduction to Metamodels<a class="headerlink" href="#introduction-to-metamodels" title="Link to this heading">¶</a></h2>
<section id="the-metamodel-concept">
<span id="nlme-metamodel-concept"></span><h3>The Metamodel Concept<a class="headerlink" href="#the-metamodel-concept" title="Link to this heading">¶</a></h3>
<p>A metamodel, distinguished by the <code class="docutils literal notranslate"><span class="pre">.mmdl</span></code> file extension,
is a self-contained text file that encapsulates all necessary components
for running a Pharmacometric Modeling Language (PML) model. It serves as
a comprehensive container, bundling the model code, data file reference,
column mappings, and engine instructions into a single, human-readable
file, analogous to a NONMEM control file.</p>
<p>The primary purpose of a metamodel is to simplify the
execution and management of PML models, particularly within the
Certara.RsNLME ecosystem. While PML is the core modeling language for
both Phoenix NLME and RsNLME, a basic PML model file (<code class="docutils literal notranslate"><span class="pre">.mdl</span></code>) only
contains the model’s structural equations and statements. It does not
specify which dataset to use, how to map data columns to model variables
(e.g., concentration, time), or what estimation engine settings to
apply.</p>
<p>A metamodel solves this by integrating these separate pieces of
information into a single, structured <code class="docutils literal notranslate"><span class="pre">.mmdl</span></code> file. This makes models
more portable, reproducible, and easier to run from both R (using
<code class="docutils literal notranslate"><span class="pre">Certara.RsNLME</span></code>) and command-line interfaces.</p>
<p><strong>Comparison with Other Systems:</strong></p>
<ul class="simple">
<li><p><strong>Phoenix NLME Project:</strong> In the Phoenix NLME graphical user
interface, the project file (<code class="docutils literal notranslate"><span class="pre">.phxproj</span></code>) holds the model, data, and
mappings together in a binary format. A metamodel provides a
text-based, human-readable equivalent of this integration.</p></li>
<li><p><strong>NONMEM Control Stream:</strong> The structure and function of a metamodel
are conceptually very similar to a NONMEM control stream (<code class="docutils literal notranslate"><span class="pre">.ctl</span></code>
file), which also combines model specification (<code class="docutils literal notranslate"><span class="pre">$PK</span></code>, <code class="docutils literal notranslate"><span class="pre">$ERROR</span></code>),
data linkage (<code class="docutils literal notranslate"><span class="pre">$DATA</span></code>), and estimation instructions (<code class="docutils literal notranslate"><span class="pre">$EST</span></code>) into
one file.</p></li>
</ul>
<p><strong>Metamodel Structure:</strong> Metamodels are organized into distinct blocks,
each beginning with a double number sign (<code class="docutils literal notranslate"><span class="pre">##</span></code>) followed by the
block’s name (e.g., <code class="docutils literal notranslate"><span class="pre">##DATA</span></code>, <code class="docutils literal notranslate"><span class="pre">##MODEL</span></code>). Comments within a
metamodel follow standard PML syntax: <code class="docutils literal notranslate"><span class="pre">#</span></code> or <code class="docutils literal notranslate"><span class="pre">//</span></code> for single-line
comments, and <code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">...</span> <span class="pre">*/</span></code> for multi-line comments.</p>
<p><strong>Keywords:</strong> metamodel, .mmdl, container, PML, RsNLME, Phoenix NLME, NONMEM control file</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-blocks"><span class="std std-ref">Metamodel Blocks</span></a>, <a class="reference internal" href="#nlme-model-structure"><span class="std std-ref">PML Model Structure</span></a></p>
</section>
</section>
<section id="metamodel-structure">
<h2>Metamodel Structure<a class="headerlink" href="#metamodel-structure" title="Link to this heading">¶</a></h2>
<section id="metamodel-blocks">
<span id="nlme-metamodel-blocks"></span><h3>Metamodel Blocks<a class="headerlink" href="#metamodel-blocks" title="Link to this heading">¶</a></h3>
<p>A metamodel file is structured into distinct,
case-insensitive blocks, each starting with a double number sign
(<code class="docutils literal notranslate"><span class="pre">##</span></code>) followed by the block name. The most critical blocks are
<code class="docutils literal notranslate"><span class="pre">##DATA</span></code>, <code class="docutils literal notranslate"><span class="pre">##MODEL</span></code>, and <code class="docutils literal notranslate"><span class="pre">##MAP</span></code>, which define the dataset, the
PML code, and the column mappings, respectively. Other blocks like
<code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> and <code class="docutils literal notranslate"><span class="pre">##TABLES</span></code> provide instructions for model execution
and output generation.</p>
<p>The following blocks are used to organize the information
within a <code class="docutils literal notranslate"><span class="pre">.mmdl</span></code> file.</p>
<ul class="simple">
<li><p><strong>Informational Blocks:</strong></p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">##Author</span></code>: Specifies the name of the model author (e.g., <code class="docutils literal notranslate"><span class="pre">##Author:</span> <span class="pre">A.</span> <span class="pre">User</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">##Description</span></code>: Provides a text description of the model’s purpose. This is used by external tools like Pirana for display.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">##Based</span> <span class="pre">on</span></code>: Indicates the filename of a parent or reference metamodel, used by Pirana to construct model development trees.</p></li>
<li><p>These three blocks are optional and are not used by the NLME engine during estimation.</p></li>
</ul>
</li>
</ul>
<ul id="nlme-data">
<li><p><code class="docutils literal notranslate"><span class="pre">##DATA</span></code></p>
<ul class="simple">
<li><p><strong>Required.</strong> This block specifies the path to the input dataset
<strong>on a single line</strong>.</p></li>
<li><p>The path can be absolute or relative to the location of the
<code class="docutils literal notranslate"><span class="pre">.mmdl</span></code> file.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Certara.RsNLME</span></code> package uses the <code class="docutils literal notranslate"><span class="pre">data.table::fread()</span></code>
function to load the specified data file.</p></li>
<li><p><strong>Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">##DATA</span> <span class="pre">path/to/your/data.csv</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">##MODEL</span></code></p>
<ul>
<li><p><strong>Required.</strong> This block contains the complete Pharmacometric
Modeling Language (PML) code for the model.</p></li>
<li><p>The syntax within this block must conform to standard PML rules.</p></li>
<li><p><strong>Syntax:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##MODEL</span>
<span class="n">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="o">//</span> <span class="n">PML</span> <span class="n">statements</span> <span class="n">go</span> <span class="n">here</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
<ul id="nlme-map">
<li><p><code class="docutils literal notranslate"><span class="pre">##MAP</span></code></p>
<ul class="simple">
<li><p>Defines the mappings between PML model variables and the columns
in the dataset specified in <code class="docutils literal notranslate"><span class="pre">##DATA</span></code>.</p></li>
<li><p><strong>Syntax:</strong> Mappings are defined using
<code class="docutils literal notranslate"><span class="pre">variableName</span> <span class="pre">=</span> <span class="pre">columnName</span></code>.</p></li>
<li><p>If a mapping for a model variable is omitted, the engine assumes
the data column has the exact same name as the model variable
(e.g., a mapping for <code class="docutils literal notranslate"><span class="pre">CObs</span></code> is equivalent to writing
<code class="docutils literal notranslate"><span class="pre">CObs</span> <span class="pre">=</span> <span class="pre">CObs</span></code>).</p></li>
<li><p>This block is also used to map <strong>special variables</strong> that control
model behavior but may not be explicitly defined in the
<code class="docutils literal notranslate"><span class="pre">##MODEL</span></code> block:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">id</span></code>: <strong>Required for population models.</strong> Maps up to five
columns that uniquely identify each subject. If unmapped, the
model is treated as an individual fit. (e.g.,
<code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">=</span> <span class="pre">SubjectID</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: <strong>Required for time-based models</strong> (any model
with a <code class="docutils literal notranslate"><span class="pre">deriv</span></code> statement). Maps the time column. (e.g.,
<code class="docutils literal notranslate"><span class="pre">time</span> <span class="pre">=</span> <span class="pre">Time</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dosingCompartmentName_Rate</span></code> / <code class="docutils literal notranslate"><span class="pre">..._Duration</span></code>:
Specifies that a dosing compartment receives an infusion, with
the rate or duration defined in the mapped data column. (e.g.,
<code class="docutils literal notranslate"><span class="pre">A1_Duration</span> <span class="pre">=</span> <span class="pre">DUR</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SS</span></code>, <code class="docutils literal notranslate"><span class="pre">ADDL</span></code>, <code class="docutils literal notranslate"><span class="pre">II</span></code>: Map columns containing
steady-state flags, additional dose flags, and the inter-dose
interval, respectively. <code class="docutils literal notranslate"><span class="pre">II</span></code> is required if <code class="docutils literal notranslate"><span class="pre">SS</span></code> or
<code class="docutils literal notranslate"><span class="pre">ADDL</span></code> are used.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MDV</span></code>: Maps a column containing Missing Data Value flags.
Rows with a non-zero value in this column are ignored during
estimation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Reset</span></code>: Maps a column that flags when to reset the
model’s state (time and compartment amounts).</p></li>
</ul>
</li>
<li><p><strong>Categorical Covariates:</strong> Allows for on-the-fly definition of
labels for character-based categorical data. (e.g.,
<code class="docutils literal notranslate"><span class="pre">Sex</span> <span class="pre">=</span> <span class="pre">Gender(Male</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">Female</span> <span class="pre">=</span> <span class="pre">1)</span></code>).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code></p>
<ul>
<li><p>Provides an alternative and more powerful way to define column
mappings using the full native syntax of the NLME engine’s column
definition file.</p></li>
<li><p>This block is useful for complex mappings that cannot be expressed
through the simpler <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> syntax.</p></li>
<li><p>Definitions from <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> and <code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code> are combined. If there
is a conflict, the <code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code> definition may take precedence.</p></li>
<li><p><strong>Example Syntax:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##COLDEF</span>
<span class="nb">id</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span>
<span class="n">obs</span><span class="p">(</span><span class="n">CObs</span><span class="o">&lt;-</span><span class="s2">&quot;conc&quot;</span><span class="p">)</span>
<span class="n">covr</span><span class="p">(</span><span class="n">sex</span><span class="o">&lt;-</span><span class="s2">&quot;sex&quot;</span><span class="p">(</span><span class="s2">&quot;male&quot;</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;female&quot;</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">##DOSING</span> <span class="pre">CYCLE</span></code></p>
<ul class="simple">
<li><p>An alternative block specifically for defining <code class="docutils literal notranslate"><span class="pre">ADDL</span></code> or <code class="docutils literal notranslate"><span class="pre">SS</span></code>
dosing cycles without needing to add <code class="docutils literal notranslate"><span class="pre">ADDL</span></code> or <code class="docutils literal notranslate"><span class="pre">II</span></code> columns to
the source dataset.</p></li>
<li><p><strong>Syntax Example:</strong>
<code class="docutils literal notranslate"><span class="pre">SS</span> <span class="pre">=</span> <span class="pre">flag_col</span> <span class="pre">Dosepoint</span> <span class="pre">=</span> <span class="pre">A1</span> <span class="pre">Amount</span> <span class="pre">=</span> <span class="pre">100</span> <span class="pre">Delta</span> <span class="pre">=</span> <span class="pre">24</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code></p>
<ul class="simple">
<li><p>Specifies arguments for the estimation engine, using the syntax of
the <code class="docutils literal notranslate"><span class="pre">engineParams()</span></code> function in the <code class="docutils literal notranslate"><span class="pre">Certara.RsNLME</span></code> package.
Multiple arguments can be separated by commas or newlines.</p></li>
<li><p>If this block is omitted, default engine parameters are used.</p></li>
<li><p><strong>Sequential Estimation:</strong> Multiple <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> blocks can be
included. They will be executed sequentially, with each run
starting from the final parameter estimates of the previous one.</p></li>
<li><p><strong>Example Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">##ESTARGS</span> <span class="pre">method</span> <span class="pre">=</span> <span class="pre">QRPEM,</span> <span class="pre">numIterations</span> <span class="pre">=</span> <span class="pre">50</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">##SIMARGS</span></code></p>
<ul class="simple">
<li><p>Specifies arguments for model simulation runs. Key arguments
include <code class="docutils literal notranslate"><span class="pre">numReplicates</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code>.</p></li>
<li><p>Multiple <code class="docutils literal notranslate"><span class="pre">##SIMARGS</span></code> and <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> blocks can be used. All
estimation runs (<code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code>) are completed before any
simulation runs (<code class="docutils literal notranslate"><span class="pre">##SIMARGS</span></code>) begin.</p></li>
<li><p><strong>Example Syntax:</strong> <code class="docutils literal notranslate"><span class="pre">##SIMARGS</span> <span class="pre">numReplicates</span> <span class="pre">=</span> <span class="pre">200,</span> <span class="pre">seed</span> <span class="pre">=</span> <span class="pre">1234</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">##TABLES</span></code></p>
<ul class="simple">
<li><p>Defines one or more custom output tables. By default, the engine
already creates a <code class="docutils literal notranslate"><span class="pre">posthoc.csv</span></code> table.</p></li>
<li><p>Uses the standard PML <code class="docutils literal notranslate"><span class="pre">table()</span></code> syntax. Tables can also be
defined in the <code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code> block.</p></li>
<li><p><strong>Example Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">##TABLES</span> <span class="pre">table(file=&quot;conc_vs_time.csv&quot;,</span> <span class="pre">time(seq(0,</span> <span class="pre">24,</span> <span class="pre">0.5)),</span> <span class="pre">C,</span> <span class="pre">V)</span></code></p></li>
</ul>
</li>
</ul>
<p><strong>Keywords:</strong> ##Author, ##Description, ##Based on, ##DATA, ##MAP, ##COLDEF, ##MODEL, ##ESTARGS, ##SIMARGS, ##TABLES, ##DOSING CYCLE, block, metamodel structure</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-concept"><span class="std std-ref">The Metamodel Concept</span></a>, <a class="reference internal" href="#nlme-model-structure"><span class="std std-ref">PML Model Structure</span></a>.</p>
</section>
</section>
<section id="execution-control-and-output">
<h2>Execution Control and Output<a class="headerlink" href="#execution-control-and-output" title="Link to this heading">¶</a></h2>
<section id="estargs-estimation-engine-arguments">
<span id="nlme-estargs"></span><h3>##ESTARGS: Estimation Engine Arguments<a class="headerlink" href="#estargs-estimation-engine-arguments" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> block specifies arguments that control
the model estimation process, overriding the default behavior of the
NLME engine. Multiple <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> blocks can be used to define a
sequence of estimation steps. Key arguments include <code class="docutils literal notranslate"><span class="pre">method</span></code> to select
the algorithm and <code class="docutils literal notranslate"><span class="pre">numIterations</span></code> to control its duration.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> block provides direct control over the
NLME estimation engine. Its arguments mirror those found in the
<code class="docutils literal notranslate"><span class="pre">engineParams()</span></code> function of the <code class="docutils literal notranslate"><span class="pre">Certara.RsNLME</span></code> R package.
Arguments can be separated by commas or newlines.</p>
<p><strong>Common Use Case: Sequential Estimation</strong> A powerful feature is the
ability to define multiple <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> blocks. They are executed in
the order they appear in the metamodel. A common strategy is to use a
fast but less precise method first to get good initial estimates, and
then use a more robust algorithm for the final estimation.</p>
<p><strong>Example of a two-stage estimation:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##ESTARGS method = QRPEM, numIterations = 300</span>
<span class="c1">##ESTARGS method = FOCE-ELS, numIterations = 700</span>
</pre></div>
</div>
<p>In this example, the engine first runs 300 iterations of the QRPEM
algorithm. The resulting parameter estimates are then used as the
starting point for a second run of 700 iterations using the FOCE-ELS
algorithm.</p>
<p><strong>Key Arguments:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">method</span></code>: Specifies the estimation algorithm. The choice of
method is critical and depends on the model type.</p>
<ul>
<li><p><strong>For population models</strong>, common options include:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;QRPEM&quot;</span></code>: A robust stochastic algorithm, good for complex
models and finding initial estimates.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;FOCE-ELS&quot;</span></code>: A fast and widely used First-Order Conditional
Estimation method. This is often the default.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;Laplacian&quot;</span></code>: The default method for models with BQL data or
count data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;FOCE-LB&quot;</span></code>: Similar to FOCE-ELS, the Lindstrom-Bates
algorithm.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;IT2S-EM&quot;</span></code>: An iterative two-stage algorithm.</p></li>
</ul>
</li>
<li><p><strong>For individual models</strong>: <code class="docutils literal notranslate"><span class="pre">&quot;Naive-Pooled&quot;</span></code> is the only option.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">numIterations</span></code>: A non-negative integer specifying the maximum
number of iterations for the chosen method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">stdErr</span></code>: Controls the method for calculating standard errors
of the parameter estimates.</p>
<ul>
<li><p>Common options include <code class="docutils literal notranslate"><span class="pre">&quot;Sandwich&quot;</span></code> (the default for FOCE-type
methods), <code class="docutils literal notranslate"><span class="pre">&quot;Hessian&quot;</span></code>, and <code class="docutils literal notranslate"><span class="pre">&quot;Fisher-Score&quot;</span></code>.</p></li>
<li><p>Setting <code class="docutils literal notranslate"><span class="pre">stdErr</span> <span class="pre">=</span> <span class="pre">&quot;None&quot;</span></code> disables standard error calculation,
which can speed up runs, especially during initial model
development.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">numIntegratePtsAGQ</span></code>: Specifies the number of quadrature points
for Adaptive Gaussian Quadrature, used to improve accuracy in
<code class="docutils literal notranslate"><span class="pre">&quot;FOCE-ELS&quot;</span></code> or <code class="docutils literal notranslate"><span class="pre">&quot;Laplacian&quot;</span></code> methods, particularly for models
with high shrinkage. A value greater than 1 enables AGQ.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">logTransform</span></code>: A logical value (<code class="docutils literal notranslate"><span class="pre">TRUE</span></code>/<code class="docutils literal notranslate"><span class="pre">FALSE</span></code>) that
controls how models with a log-additive error structure (e.g.,
<code class="docutils literal notranslate"><span class="pre">C*exp(eps)</span></code>) are handled, typically by enabling or disabling a
Log-Transform Both Sides (LTBS) approach during the fit.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code>: A logical value. If <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>, it forces the engine to
preserve the original sort order of the input dataset. This is
critical for models with reset events or other sequence-dependent
logic.</p></li>
</ul>
<p>A full list of available arguments can be found in the
<code class="docutils literal notranslate"><span class="pre">Certara.RsNLME::engineParams()</span></code> documentation.</p>
<p><strong>Keywords:</strong> ##ESTARGS, engine arguments, method, numIterations, stdErr, QRPEM, FOCE, Laplacian</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-blocks"><span class="std std-ref">Metamodel Blocks</span></a>, <a class="reference internal" href="#nlme-simargs"><span class="std std-ref">##SIMARGS</span></a>, <a class="reference internal" href="#nlme-tables"><span class="std std-ref">##TABLES</span></a></p>
</section>
<section id="simargs-simulation-arguments">
<span id="nlme-simargs"></span><h3>##SIMARGS: Simulation Arguments<a class="headerlink" href="#simargs-simulation-arguments" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">##SIMARGS</span></code> block configures simulation runs that are
executed <em>after</em> all model estimations are complete. Its key arguments,
<code class="docutils literal notranslate"><span class="pre">numReplicates</span></code> and <code class="docutils literal notranslate"><span class="pre">seed</span></code>, control the number of simulated datasets
to generate and ensure the reproducibility of the results.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">##SIMARGS</span></code> block is used to specify arguments for
running simulations based on the final parameter estimates obtained from
the <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> blocks.</p>
<p><strong>Execution Order:</strong> In a metamodel containing both <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> and
<code class="docutils literal notranslate"><span class="pre">##SIMARGS</span></code> blocks, all estimation runs are performed first. The final
parameter estimates from the <em>last</em> completed <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> block are
then used as the basis for all subsequent simulation runs defined by
<code class="docutils literal notranslate"><span class="pre">##SIMARGS</span></code> blocks.</p>
<p><strong>Key Arguments:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">numReplicates</span></code>: An integer specifying the number of simulation
replicates to generate. For example, <code class="docutils literal notranslate"><span class="pre">numReplicates</span> <span class="pre">=</span> <span class="pre">200</span></code> will
create 200 simulated datasets, which is common for a Visual
Predictive Check (VPC). The default value is 100.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seed</span></code>: An integer used to initialize the random number
generator. Setting a specific seed ensures that simulation results
are reproducible; running the same model with the same seed will
produce the exact same simulated output. The default value is 1234.</p></li>
<li><p><strong>Other Arguments</strong>: Technical arguments from the <code class="docutils literal notranslate"><span class="pre">engineParams()</span></code>
function can also be used here to control the simulation process,
such as:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">sort</span></code>: A logical value (<code class="docutils literal notranslate"><span class="pre">TRUE</span></code>/<code class="docutils literal notranslate"><span class="pre">FALSE</span></code>) to control data
sorting during simulation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ODE</span></code>, <code class="docutils literal notranslate"><span class="pre">rtolODE</span></code>, <code class="docutils literal notranslate"><span class="pre">atolODE</span></code>: Arguments to control the ODE
solver settings for the simulation runs.</p></li>
</ul>
</li>
</ul>
<p><strong>Example:</strong> This metamodel snippet first estimates the parameters and
then uses those final estimates to run a reproducible simulation.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, estimate the model parameters</span>
<span class="c1">##ESTARGS method = FOCE-ELS, numIterations = 1000</span>

<span class="c1"># Then, using the final estimates, run a simulation of 500 replicates</span>
<span class="c1">##SIMARGS numReplicates = 500, seed = 42</span>
</pre></div>
</div>
<p><strong>Keywords:</strong> ##SIMARGS, simulation, numReplicates, seed</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-blocks"><span class="std std-ref">Metamodel Blocks</span></a>, <a class="reference internal" href="#nlme-estargs"><span class="std std-ref">##ESTARGS</span></a>, <a class="reference internal" href="#nlme-tables"><span class="std std-ref">##TABLES</span></a></p>
</section>
<section id="tables-defining-output-tables">
<span id="nlme-tables"></span><h3>##TABLES: Defining Output Tables<a class="headerlink" href="#tables-defining-output-tables" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">##TABLES</span></code> block is used to define custom output
files containing model variables and calculated values from either
estimation or simulation runs. It is crucial to use the <code class="docutils literal notranslate"><span class="pre">table()</span></code>
statement for estimation outputs and the <code class="docutils literal notranslate"><span class="pre">simtbl()</span></code> statement for
simulation outputs to ensure the correct data is generated at the right
stage.</p>
<p>While the NLME engine produces a default <code class="docutils literal notranslate"><span class="pre">posthoc.csv</span></code>
file for estimation runs, the <code class="docutils literal notranslate"><span class="pre">##TABLES</span></code> block provides complete
control over the content, structure, and timing of custom data tables.</p>
<p><code class="docutils literal notranslate"><span class="pre">table()</span></code> vs. <code class="docutils literal notranslate"><span class="pre">simtbl()</span></code>: This distinction is critical and
determines when the table is generated:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">table(...)</span></code>: Defines an output table generated during an
<strong>estimation</strong> run (from an <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> block). This is used for
creating tables of predictions, residuals, individual parameters,
etc., based on the original data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">simtbl(...)</span></code>: Defines an output table generated during a
<strong>simulation</strong> run (from a <code class="docutils literal notranslate"><span class="pre">##SIMARGS</span></code> block). This is used for
saving the results of simulations, such as data for a Visual
Predictive Check (VPC).</p></li>
</ul>
<p><strong>Default Table:</strong> For estimation runs only, a <code class="docutils literal notranslate"><span class="pre">posthoc.csv</span></code> table is
created by default. It contains the structural parameters and covariates
for each subject at each time point present in the original input
dataset.</p>
<p><strong>Table Syntax Components:</strong> Both <code class="docutils literal notranslate"><span class="pre">table()</span></code> and <code class="docutils literal notranslate"><span class="pre">simtbl()</span></code> share a
common syntax structure composed of several parts:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">file=&quot;filename.csv&quot;</span></code>: <strong>(Required)</strong> Specifies the name of the
output CSV file.</p></li>
<li><p><strong>Triggers (When to write a row):</strong> These arguments specify the
events that cause a row to be written to the output file. Multiple
triggers can be used.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">time(...)</span></code>: At specified time points. Can be a list of numbers
or a sequence (e.g., <code class="docutils literal notranslate"><span class="pre">time(0,</span> <span class="pre">10,</span> <span class="pre">seq(2,</span> <span class="pre">8,</span> <span class="pre">0.1))</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dose(...)</span></code>: At each dosing event for the named compartment(s)
(e.g., <code class="docutils literal notranslate"><span class="pre">dose(A1)</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">covr(...)</span></code>: Whenever a specified covariate’s value changes
(e.g., <code class="docutils literal notranslate"><span class="pre">covr(BW)</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">obs(...)</span></code>: At each time point corresponding to an observation
of the named variable(s) (e.g., <code class="docutils literal notranslate"><span class="pre">obs(CObs)</span></code>).</p></li>
</ul>
</li>
<li><p><strong>Variables (What to write in the columns):</strong></p>
<ul>
<li><p>A comma-separated list of model variables (e.g., structural
parameters, compartment amounts, concentrations) to include in the
output (e.g., <code class="docutils literal notranslate"><span class="pre">C,</span> <span class="pre">V,</span> <span class="pre">Cl,</span> <span class="pre">IPRED</span></code>).</p></li>
</ul>
</li>
<li><p><strong>Special Variables (specvar)</strong>:</p>
<ul>
<li><p>Used to request special, calculated variables that are derived by
the engine during the run.</p></li>
<li><p><strong>Rule:</strong> The <code class="docutils literal notranslate"><span class="pre">specvar()</span></code> clause can <strong>only</strong> be used in a
<code class="docutils literal notranslate"><span class="pre">table()</span></code> definition that also contains an <code class="docutils literal notranslate"><span class="pre">obs()</span></code> trigger.
The special variables are calculated specifically at the
observation time points.</p></li>
<li><p>Common <code class="docutils literal notranslate"><span class="pre">specvar</span></code> variables include:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">TAD</span></code>: Time After Dose.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IRES</span></code>: Individual Residuals.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IWRES</span></code>: Individual Weighted Residuals.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Weight</span></code>: The statistical weight of the current observation.</p></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Output Mode (mode)</strong>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">mode</span> <span class="pre">=</span> <span class="pre">keep</span></code>: This is a special mode that overrides other
time-based triggers (<code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">dose</span></code>, etc.). It forces the
output table to contain the exact same number of rows as the input
dataset, writing output only at the original time points.</p></li>
</ul>
</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li><p><strong>Post-hoc parameters at time zero:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##TABLES</span>
<span class="n">table</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;parameters_t0.csv&quot;</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Ka</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">Cl</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p><strong>Residuals and special variables at observation times:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##TABLES</span>
<span class="n">table</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;residuals.csv&quot;</span><span class="p">,</span> <span class="n">obs</span><span class="p">(</span><span class="n">CObs</span><span class="p">),</span> <span class="n">IPRED</span><span class="p">,</span> <span class="n">specvar</span><span class="p">(</span><span class="n">TAD</span><span class="p">,</span> <span class="n">IRES</span><span class="p">,</span> <span class="n">IWRES</span><span class="p">))</span>
</pre></div>
</div>
</li>
<li><p><strong>A simulated dataset matching the original data structure:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##TABLES</span>
<span class="n">simtbl</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;simulated_data.csv&quot;</span><span class="p">,</span> <span class="n">CObs</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">keep</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p><strong>A dense grid of simulated concentration profiles:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##TABLES</span>
<span class="n">simtbl</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;simulation_profiles.csv&quot;</span><span class="p">,</span> <span class="n">time</span><span class="p">(</span><span class="n">seq</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)),</span> <span class="n">C</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">Cl</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p><strong>Keywords:</strong> ##TABLES, table, simtbl, output, file, time, dose, covr, obs, specvar, mode, keep</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-blocks"><span class="std std-ref">Metamodel Blocks</span></a>, <a class="reference internal" href="#nlme-estargs"><span class="std std-ref">##ESTARGS</span></a>, <a class="reference internal" href="#nlme-simargs"><span class="std std-ref">##SIMARGS</span></a></p>
</section>
</section>
<section id="linking-data-to-the-model">
<h2>Linking Data to the Model<a class="headerlink" href="#linking-data-to-the-model" title="Link to this heading">¶</a></h2>
<section id="data-mapping-map-and-coldef">
<h3>Data Mapping: ##MAP and ##COLDEF<a class="headerlink" href="#data-mapping-map-and-coldef" title="Link to this heading">¶</a></h3>
<p>Data mapping is the crucial step of linking columns in your
dataset to variables within your PML model. Metamodels provide two
blocks for this purpose: <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> for simple, direct assignments and
<code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code> for the full, native column definition syntax. Both can be
used together to define all necessary connections.</p>
<p>For the NLME engine to understand your dataset, you must
tell it which column corresponds to subject IDs, which to time, which to
observations, and so on.</p>
<section id="the-map-block">
<h4><strong>The ##MAP Block</strong><a class="headerlink" href="#the-map-block" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> block is the primary and most convenient way to define
column mappings.</p>
<p><strong>Basic Syntax:</strong> Mappings are specified as
<code class="docutils literal notranslate"><span class="pre">variableName</span> <span class="pre">=</span> <span class="pre">columnName</span></code> and are all placed on the <strong>same line</strong> as
the <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> keyword, separated by spaces or commas. If a model
variable is not explicitly mapped, the engine assumes the dataset
contains a column with the exact same name (e.g., <code class="docutils literal notranslate"><span class="pre">CObs</span></code> in the model
is implicitly mapped to a <code class="docutils literal notranslate"><span class="pre">CObs</span></code> column in the data).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##MAP C = CONC, Weight = BW, id = SubjectID</span>
</pre></div>
</div>
<p><strong>Special Mappings:</strong> The <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> block is also used to define
mappings for special variables that are essential for model execution
but are not part of the PML model code itself.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: <strong>(Required for population models)</strong>. Maps a
column to be used as the subject identifier. Up to five
comma-separated columns can be specified for composite keys. If
<code class="docutils literal notranslate"><span class="pre">id</span></code> is not mapped, the data is treated as if from a single
individual.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: <strong>(Required for time-based models)</strong>. Maps
the column containing the time of the records.</p></li>
<li><p><strong>Infusion Mappings</strong>: To specify an infusion dose, you map a rate or
a duration to a specific dosing compartment from your model.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">dosingCompartmentName_Rate</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: Maps an infusion rate
for the specified dosepoint.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dosingCompartmentName_Duration</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: Maps an infusion
duration for the specified dosepoint.</p></li>
<li><p>Example: <code class="docutils literal notranslate"><span class="pre">A1_Duration</span> <span class="pre">=</span> <span class="pre">DUR</span></code> maps the <code class="docutils literal notranslate"><span class="pre">DUR</span></code> column to the
duration of infusions into compartment <code class="docutils literal notranslate"><span class="pre">A1</span></code>.</p></li>
</ul>
</li>
<li><p><strong>Dosing Event Mappings</strong>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">SS</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: Maps the column containing the steady-state
dose flag.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ADDL</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: Maps the column containing the “additional
doses” flag.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">II</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: <strong>(Required if SS or ADDL are used)</strong>. Maps the column containing the inter-dose interval.</p></li>
</ul>
</li>
<li><p><strong>Data Flag Mappings</strong>:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">MDV</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: Maps the “Missing Data Value” column. Rows
where this column contains a non-zero value are ignored for
parameter estimation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Reset</span> <span class="pre">=</span> <span class="pre">columnName</span></code>: Maps the column containing a reset flag.
On rows with a non-zero value, the model’s state (time and
compartment amounts) is reset.</p></li>
</ul>
</li>
<li><p><strong>Categorical Covariate Labeling</strong>:</p>
<ul>
<li><p>For a categorical covariate (defined with <code class="docutils literal notranslate"><span class="pre">covariate(Sex())</span></code> in
PML), you can provide human-readable labels for the values in your
data.</p></li>
<li><p><strong>Syntax:</strong>
<code class="docutils literal notranslate"><span class="pre">ModelVariableName</span> <span class="pre">=</span> <span class="pre">ColumnName(Label1</span> <span class="pre">=</span> <span class="pre">Value1,</span> <span class="pre">Label2</span> <span class="pre">=</span> <span class="pre">Value2)</span></code></p></li>
<li><p><strong>Example:</strong> <code class="docutils literal notranslate"><span class="pre">Sex</span> <span class="pre">=</span> <span class="pre">Gender(Male</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">Female</span> <span class="pre">=</span> <span class="pre">1)</span></code> maps the
<code class="docutils literal notranslate"><span class="pre">Gender</span></code> data column to the <code class="docutils literal notranslate"><span class="pre">Sex</span></code> model variable, treating
rows with <code class="docutils literal notranslate"><span class="pre">0</span></code> as “Male” and <code class="docutils literal notranslate"><span class="pre">1</span></code> as “Female”.</p></li>
</ul>
</li>
</ul>
</section>
<section id="the-coldef-block">
<h4><strong>The ##COLDEF Block</strong><a class="headerlink" href="#the-coldef-block" title="Link to this heading">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code> block provides a more powerful and flexible alternative
for defining column mappings. It uses the full, native syntax that the
NLME engine uses internally, which is documented in the PML reference
guides.</p>
<p><strong>When to Use</strong> <code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code>: You should use <code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code> when a mapping
is too complex for the simple <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> syntax. This is rare, but can
occur with advanced model structures.</p>
<p><strong>Relationship with</strong> <code class="docutils literal notranslate"><span class="pre">##MAP</span></code>: You can use both <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> and
<code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code> in the same metamodel. The engine will combine the
definitions from both blocks. If a mapping is defined in both places,
the <code class="docutils literal notranslate"><span class="pre">##COLDEF</span></code> definition may take precedence.</p>
<p><strong>Example using native syntax:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##COLDEF</span>
  <span class="nb">id</span><span class="p">(</span><span class="s2">&quot;Subject&quot;</span><span class="p">)</span>
  <span class="n">time</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
  <span class="n">dose</span><span class="p">(</span><span class="n">A1</span><span class="o">&lt;-</span><span class="s2">&quot;Dose&quot;</span><span class="p">)</span>
  <span class="n">obs</span><span class="p">(</span><span class="n">CObs</span><span class="o">&lt;-</span><span class="s2">&quot;Conc&quot;</span><span class="p">)</span>
  <span class="n">covr</span><span class="p">(</span><span class="n">wt</span><span class="o">&lt;-</span><span class="s2">&quot;Weight&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Keywords:</strong> ##MAP, ##COLDEF, mapping, id, time, rate, duration, SS, ADDL, II, MDV, Reset, categorical covariate</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-blocks"><span class="std std-ref">Metamodel Blocks</span></a>, <a class="reference internal" href="#nlme-data"><span class="std std-ref">##DATA</span></a>, <a class="reference internal" href="#nlme-dosing-cycle"><span class="std std-ref">##DOSING CYCLE</span></a></p>
</section>
</section>
</section>
<section id="advanced-dosing-and-a-complete-example">
<h2>Advanced Dosing and a Complete Example<a class="headerlink" href="#advanced-dosing-and-a-complete-example" title="Link to this heading">¶</a></h2>
<section id="dosing-cycle">
<span id="nlme-dosing-cycle"></span><h3>##DOSING CYCLE<a class="headerlink" href="#dosing-cycle" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">##DOSING</span> <span class="pre">CYCLE</span></code> block provides an alternative, powerful syntax for defining steady-state (<code class="docutils literal notranslate"><span class="pre">SS</span></code>) or additional
(<code class="docutils literal notranslate"><span class="pre">ADDL</span></code>) dosing events directly within the metamodel, without requiring pre-existing <code class="docutils literal notranslate"><span class="pre">ADDL</span></code> or <code class="docutils literal notranslate"><span class="pre">II</span></code> columns in the dataset. This
is particularly useful for simulations or when the dosing schedule is fixed. It defines the parameters of a dosing regimen that is triggered
by a flag in a specified data column.</p>
<p>While the <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> block can link existing <code class="docutils literal notranslate"><span class="pre">ADDL</span></code> and <code class="docutils literal notranslate"><span class="pre">II</span></code> data columns to the model, the <code class="docutils literal notranslate"><span class="pre">##DOSING</span> <span class="pre">CYCLE</span></code> block allows
you to <em>define</em> the dosing cycle itself based on a trigger column.</p>
<p><strong>Syntax:</strong> The block begins with either <code class="docutils literal notranslate"><span class="pre">SS</span></code> or <code class="docutils literal notranslate"><span class="pre">ADDL</span></code>, followed by
a series of <code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">=</span> <span class="pre">value</span></code> pairs.</p>
<ul class="simple">
<li><p><strong>For Steady-State Dosing (SS)</strong>:
<code class="docutils literal notranslate"><span class="pre">SS</span> <span class="pre">=</span> <span class="pre">[COL]</span> <span class="pre">Dosepoint</span> <span class="pre">=</span> <span class="pre">[CMT]</span> <span class="pre">Amount</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span> <span class="pre">Delta</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span> <span class="pre">Rate</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span> <span class="pre">Duration</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span></code></p></li>
<li><p><strong>For Additional Doses (ADDL)</strong>:
<code class="docutils literal notranslate"><span class="pre">ADDL</span> <span class="pre">=</span> <span class="pre">[COL]</span> <span class="pre">Delta</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span> <span class="pre">Dosepoint</span> <span class="pre">=</span> <span class="pre">[CMT]</span> <span class="pre">Amount</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span> <span class="pre">Rate</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span> <span class="pre">Duration</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span></code></p></li>
</ul>
<p><strong>Key-Value Pairs:</strong></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SS</span> <span class="pre">=</span> <span class="pre">[COL]</span></code> or <code class="docutils literal notranslate"><span class="pre">ADDL</span> <span class="pre">=</span> <span class="pre">[COL]</span></code>: <strong>(Required)</strong> Specifies the
data column (<code class="docutils literal notranslate"><span class="pre">[COL]</span></code>) containing the flag that triggers the dosing
cycle. The cycle is initiated on rows where this column has a
non-zero value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Dosepoint</span> <span class="pre">=</span> <span class="pre">[CMT]</span></code>: <strong>(Required)</strong> The name of the dosing
compartment (<code class="docutils literal notranslate"><span class="pre">[CMT]</span></code>) in the PML model that will receive the doses.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Amount</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span></code>: The dose amount. Can be a fixed number
(<code class="docutils literal notranslate"><span class="pre">[NUM]</span></code>) or sourced from a data column (<code class="docutils literal notranslate"><span class="pre">[COL]</span></code>).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Delta</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span></code>: The inter-dose interval (equivalent to
<code class="docutils literal notranslate"><span class="pre">II</span></code>). Can be a fixed number or sourced from a data column.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Rate</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span></code>: The infusion rate for the doses.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Duration</span> <span class="pre">=</span> <span class="pre">[NUM/COL]</span></code>: The infusion duration for the doses.</p></li>
</ul>
<p><strong>Example:</strong> This example defines a steady-state dosing regimen
triggered by the <code class="docutils literal notranslate"><span class="pre">ss_flag</span></code> column. Each cycle consists of a 100-unit
dose administered as a 2-hour infusion into compartment <code class="docutils literal notranslate"><span class="pre">A1</span></code> every 24
hours.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##DOSING CYCLE</span>
<span class="n">SS</span> <span class="o">=</span> <span class="n">ss_flag</span> <span class="n">Dosepoint</span> <span class="o">=</span> <span class="n">A1</span> <span class="n">Amount</span> <span class="o">=</span> <span class="mi">100</span> <span class="n">Duration</span> <span class="o">=</span> <span class="mi">2</span> <span class="n">Delta</span> <span class="o">=</span> <span class="mi">24</span>
</pre></div>
</div>
<p><strong>Keywords:</strong> ##DOSING CYCLE, SS, ADDL, steady-state, additional doses, Delta, Amount, Rate, Duration</p>
</section>
<section id="complete-metamodel-example">
<h3>Complete Metamodel Example<a class="headerlink" href="#complete-metamodel-example" title="Link to this heading">¶</a></h3>
<p>This section provides a complete, annotated example of a
<code class="docutils literal notranslate"><span class="pre">.mmdl</span></code> file for a one-compartment IV infusion model, demonstrating
how all the different blocks work together.</p>
<p>This example brings together all the concepts into a single
<code class="docutils literal notranslate"><span class="pre">.mmdl</span></code> file for a one-compartment IV infusion model for Warfarin.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##Description: 1-Cpt PK model with IV infusion for Warfarin</span>
<span class="c1">##Author: A. User</span>
<span class="c1">##Based on: Base_1Cpt.mmdl</span>

<span class="c1">##DATA ./warfarin_data.csv</span>

<span class="c1">##MAP id = Subject, time = Time, A1_Duration = DUR, A1 = Dose</span>

<span class="c1">##MODEL</span>
<span class="n">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1"># 1-compartment model, clearance parameterization</span>
  <span class="n">cfMicro</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">Cl</span> <span class="o">/</span> <span class="n">V</span><span class="p">)</span>
  <span class="n">C</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">/</span> <span class="n">V</span>

  <span class="c1"># Define dosepoint to receive infusions</span>
  <span class="n">dosepoint</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">idosevar</span> <span class="o">=</span> <span class="n">A1Dose</span><span class="p">)</span>

  <span class="c1"># Proportional residual error model</span>
  <span class="n">error</span><span class="p">(</span><span class="n">CEps</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
  <span class="n">observe</span><span class="p">(</span><span class="n">CObs</span> <span class="o">=</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">CEps</span><span class="p">))</span>

  <span class="c1"># Structural parameters with random effects</span>
  <span class="n">stparm</span><span class="p">(</span><span class="n">Cl</span> <span class="o">=</span> <span class="n">tvCl</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">nCl</span><span class="p">))</span>
  <span class="n">stparm</span><span class="p">(</span><span class="n">V</span> <span class="o">=</span> <span class="n">tvV</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">nV</span><span class="p">))</span>

  <span class="n">fixef</span><span class="p">(</span><span class="n">tvCl</span> <span class="o">=</span> <span class="n">c</span><span class="p">(,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="p">))</span>
  <span class="n">fixef</span><span class="p">(</span><span class="n">tvV</span> <span class="o">=</span> <span class="n">c</span><span class="p">(,</span> <span class="mi">8</span><span class="p">,</span> <span class="p">))</span>

  <span class="n">ranef</span><span class="p">(</span><span class="n">diag</span><span class="p">(</span><span class="n">nCl</span><span class="p">,</span> <span class="n">nV</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="mf">0.09</span><span class="p">,</span> <span class="mf">0.09</span><span class="p">))</span>
<span class="p">}</span>

<span class="c1">##ESTARGS</span>
  <span class="n">method</span> <span class="o">=</span> <span class="n">FOCE</span><span class="o">-</span><span class="n">ELS</span>
  <span class="n">numIterations</span> <span class="o">=</span> <span class="mi">1000</span>
  <span class="n">stdErr</span> <span class="o">=</span> <span class="s2">&quot;Sandwich&quot;</span>

<span class="c1">##SIMARGS</span>
  <span class="n">numReplicates</span> <span class="o">=</span> <span class="mi">500</span>
  <span class="n">seed</span> <span class="o">=</span> <span class="mi">42</span>

<span class="c1">##TABLES</span>
  <span class="c1"># Estimation table with residuals</span>
  <span class="n">table</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;residuals_output.csv&quot;</span><span class="p">,</span> <span class="n">obs</span><span class="p">(</span><span class="n">CObs</span><span class="p">),</span> <span class="n">specvar</span><span class="p">(</span><span class="n">IRES</span><span class="p">,</span> <span class="n">IWRES</span><span class="p">))</span>
  <span class="c1"># Simulation table matching original data structure</span>
  <span class="n">simtbl</span><span class="p">(</span><span class="n">file</span><span class="o">=</span><span class="s2">&quot;simulation_output.csv&quot;</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">CObs</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">keep</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>Keywords:</strong> example, metamodel, .mmdl, complete</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-blocks"><span class="std std-ref">Metamodel Blocks</span></a>, <a class="reference internal" href="#nlme-map"><span class="std std-ref">##MAP</span></a>, <a class="reference internal" href="#nlme-model-structure"><span class="std std-ref">PML Model Structure</span></a></p>
</section>
</section>
<section id="automated-model-search-with-pydarwin">
<h2>Automated Model Search with pyDarwin<a class="headerlink" href="#automated-model-search-with-pydarwin" title="Link to this heading">¶</a></h2>
<section id="the-metamodel-as-a-template-file">
<span id="nlme-metamodel-as-template"></span><h3>The Metamodel as a Template File<a class="headerlink" href="#the-metamodel-as-a-template-file" title="Link to this heading">¶</a></h3>
<p>For a <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> search, any valid metamodel (<code class="docutils literal notranslate"><span class="pre">.mmdl</span></code>)
file can serve as a template. It becomes a template by including one or
more special placeholders, called <strong>tokens</strong>, which are inserted at
locations where you want to test different model variations.</p>
<p>The template file provides the foundational structure for
every model that will be generated during the automated search.</p>
<p><strong>Token Syntax:</strong> The specific token syntax required is
<code class="docutils literal notranslate"><span class="pre">{TOKEN_NAME[index]}</span></code>.</p>
<p><strong>Note on Comments:</strong> The rule to not use tokens in comments means that
the token syntax itself (e.g., <code class="docutils literal notranslate"><span class="pre">{_COV_Cl[1]}</span></code>) should not be placed
inside a comment line. Standard comments that describe the purpose of a
tokenized section are perfectly acceptable and good practice.</p>
<ul>
<li><p><strong>Correct:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span># Token to modify the Cl equation
stparm(Cl = tvCl {_COV_Cl[1]} * exp(nCl))
</pre></div>
</div>
</li>
<li><p><strong>Incorrect:</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span># The following token {_COV_Cl[1]} adds the covariate effect.
stparm(Cl = tvCl {_COV_Cl[1]} * exp(nCl))
</pre></div>
</div>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">TOKEN_NAME</span></code>: This is the name of the token, which must
correspond directly to a key in the accompanying <code class="docutils literal notranslate"><span class="pre">tokens.json</span></code>
file. Token names often start with an underscore (e.g., <code class="docutils literal notranslate"><span class="pre">_COV</span></code>,
<code class="docutils literal notranslate"><span class="pre">_nCl</span></code>) to make them easily identifiable, but this is a convention,
not a requirement.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">[index]</span></code>: This is a <strong>1-based</strong> integer. It specifies which
piece of text to select from a chosen option in the <code class="docutils literal notranslate"><span class="pre">tokens.json</span></code>
file. Since options in the <code class="docutils literal notranslate"><span class="pre">tokens.json</span></code> file are defined as an
array of text strings, the index selects which string from that array
to insert.</p></li>
</ul>
<p><strong>Example of Token Usage:</strong> A token in <code class="docutils literal notranslate"><span class="pre">tokens.json</span></code> might be defined
like this:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;_COV_Cl&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="w"> </span><span class="p">],</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot; * (BW/70)^dBWdCl&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;\n\tfixef(dBWdCl = c(, 0.75, ))&quot;</span><span class="w"> </span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<p>In the metamodel template, you would use two placeholders to insert this
effect:</p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span> ##MODEL
...
stparm(Cl = tvCl {_COV_Cl[1]} * exp(nCl))
...
fixef(tvCl = c(, 1,))
{_COV_Cl[2]}
...
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> selects the second option (“on”), it will:</p>
<ol class="arabic simple">
<li><p>Replace <code class="docutils literal notranslate"><span class="pre">{_COV_Cl[1]}</span></code> with the first string: <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">(BW/70)^dBWdCl</span></code>.</p></li>
<li><p>Replace <code class="docutils literal notranslate"><span class="pre">{_COV_Cl[2]}</span></code> with the second string:
<code class="docutils literal notranslate"><span class="pre">\n\tfixef(dBWdCl</span> <span class="pre">=</span> <span class="pre">c(,</span> <span class="pre">0.75,</span> <span class="pre">))</span></code>.</p></li>
</ol>
<p>This two-part substitution allows a single token option to modify
multiple parts of the model code simultaneously (e.g., both the
<code class="docutils literal notranslate"><span class="pre">stparm</span></code> and <code class="docutils literal notranslate"><span class="pre">fixef</span></code> blocks).</p>
<p><strong>Placement of Tokens:</strong> Tokens can be placed anywhere within the
metamodel file, including:</p>
<ul class="simple">
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">##MODEL</span></code> block (most common), to change structural
equations, parameter definitions, or error models.</p></li>
<li><p>Inside the <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> block, to test different column mappings.</p></li>
<li><p>Inside <code class="docutils literal notranslate"><span class="pre">##ESTARGS</span></code> or <code class="docutils literal notranslate"><span class="pre">##TABLES</span></code> blocks, to test different engine
parameters or output definitions.</p></li>
</ul>
<p><strong>The Golden Rule:</strong> The fundamental rule of creating a template is that
after <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> performs all the token substitutions for any given
combination of choices, the resulting, fully-assembled <code class="docutils literal notranslate"><span class="pre">.mmdl</span></code> file
<strong>must be a syntactically valid metamodel</strong> that can be executed by the
NLME engine.</p>
<p><strong>Keywords:</strong> template, token, placeholder, metamodel, pyDarwin, syntax, {TOKEN[index]}</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-tokensjson"><span class="std std-ref">The tokens.json File</span></a></p>
</section>
<section id="the-tokens-json-file">
<span id="nlme-tokensjson"></span><h3>The tokens.json File<a class="headerlink" href="#the-tokens-json-file" title="Link to this heading">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">tokens.json</span></code> file is a required companion to the metamodel template. It is a JSON-formatted text file that defines all the possible code snippets
that can be substituted into the tokens in the template. The structure of this file dictates the dimensions and options of the model search.</p>
<p><strong>File Structure:</strong> The <code class="docutils literal notranslate"><span class="pre">tokens.json</span></code> file has a specific structure:</p>
<ul class="simple">
<li><p>It is a single JSON object, enclosed in curly braces <code class="docutils literal notranslate"><span class="pre">{}</span></code>.</p></li>
<li><p>The top-level keys of this object must exactly match the
<code class="docutils literal notranslate"><span class="pre">TOKEN_NAME</span></code>s used in the metamodel template.</p></li>
<li><p>The value for each <code class="docutils literal notranslate"><span class="pre">TOKEN_NAME</span></code> key is an <strong>array of options</strong>.</p></li>
<li><p>Each <strong>option</strong> is itself an <strong>array of one or more text strings</strong>.</p></li>
</ul>
<p><strong>Example Structure:</strong></p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;TOKEN_NAME_1&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;text for option 1, index 1&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;text for option 1, index 2&quot;</span><span class="w"> </span><span class="p">],</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;text for option 2, index 1&quot;</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;text for option 2, index 2&quot;</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="p">],</span>
<span class="w">  </span><span class="nt">&quot;TOKEN_NAME_2&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;text for option 1, index 1&quot;</span><span class="w"> </span><span class="p">],</span>
<span class="w">    </span><span class="p">[</span><span class="w"> </span><span class="s2">&quot;text for option 2, index 1&quot;</span><span class="w"> </span><span class="p">]</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>How it Works:</strong> When <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> builds a model, it iterates through
each token name (e.g., <code class="docutils literal notranslate"><span class="pre">&quot;TOKEN_NAME_1&quot;</span></code>). It selects one of the option
arrays (e.g., the second option
<code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">&quot;text</span> <span class="pre">for</span> <span class="pre">option</span> <span class="pre">2,</span> <span class="pre">index</span> <span class="pre">1&quot;</span> <span class="pre">,</span> <span class="pre">&quot;text</span> <span class="pre">for</span> <span class="pre">option</span> <span class="pre">2,</span> <span class="pre">index</span> <span class="pre">2&quot;</span> <span class="pre">]</span></code>).</p>
<p>Then, when it encounters a placeholder in the template like
<code class="docutils literal notranslate"><span class="pre">{TOKEN_NAME_1[index]}</span></code>, it uses the index to pick the corresponding
string from the selected option array.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">{TOKEN_NAME_1[1]}</span></code> would be replaced with
<code class="docutils literal notranslate"><span class="pre">&quot;text</span> <span class="pre">for</span> <span class="pre">option</span> <span class="pre">2,</span> <span class="pre">index</span> <span class="pre">1&quot;</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{TOKEN_NAME_1[2]}</span></code> would be replaced with
<code class="docutils literal notranslate"><span class="pre">&quot;text</span> <span class="pre">for</span> <span class="pre">option</span> <span class="pre">2,</span> <span class="pre">index</span> <span class="pre">2&quot;</span></code>.</p></li>
</ul>
<p><strong>The “Off” State:</strong> A crucial convention is to make the <em>first option</em>
for each token the “off” or “base” state. This is typically an array of
empty strings (<code class="docutils literal notranslate"><span class="pre">[</span> <span class="pre">&quot;&quot;,</span> <span class="pre">&quot;&quot;</span> <span class="pre">]</span></code>). This ensures that there is always a
baseline model generated where none of the optional features are added.</p>
<p><strong>Complete pyDarwin Search Example</strong></p>
<p>This example demonstrates a search to test for the effect of Body Weight
(<code class="docutils literal notranslate"><span class="pre">BW</span></code>) on the clearance (<code class="docutils literal notranslate"><span class="pre">Cl</span></code>) of a one-compartment IV bolus model.</p>
<p><code class="docutils literal notranslate"><span class="pre">template.mmdl</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##Description: 1-Cpt IV Bolus with BW on Cl search</span>
<span class="c1">##DATA {data_dir}/pk_data.csv</span>
<span class="c1">##MAP A1 = Dose CObs = DV BW = BW id = ID time = time</span>
<span class="c1">##MODEL</span>
<span class="n">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">cfMicro</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">Cl</span> <span class="o">/</span> <span class="n">V</span><span class="p">)</span>
  <span class="n">C</span> <span class="o">=</span> <span class="n">A1</span> <span class="o">/</span> <span class="n">V</span>
  <span class="n">dosepoint</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">idosevar</span> <span class="o">=</span> <span class="n">A1Dose</span><span class="p">)</span>
  <span class="n">error</span><span class="p">(</span><span class="n">CEps</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
  <span class="n">observe</span><span class="p">(</span><span class="n">CObs</span> <span class="o">=</span> <span class="n">C</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">CEps</span><span class="p">))</span>
  <span class="n">fcovariate</span><span class="p">(</span><span class="n">BW</span><span class="p">)</span>

  <span class="c1"># Token to modify the Cl equation</span>
  <span class="n">stparm</span><span class="p">(</span><span class="n">Cl</span> <span class="o">=</span> <span class="n">tvCl</span> <span class="p">{</span><span class="n">_COV_Cl</span><span class="p">[</span><span class="mi">1</span><span class="p">]}</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">nCl</span><span class="p">))</span>
  <span class="n">stparm</span><span class="p">(</span><span class="n">V</span> <span class="o">=</span> <span class="n">tvV</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span><span class="n">nV</span><span class="p">))</span>

  <span class="n">fixef</span><span class="p">(</span><span class="n">tvCl</span> <span class="o">=</span> <span class="n">c</span><span class="p">(,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">))</span>
  <span class="n">fixef</span><span class="p">(</span><span class="n">tvV</span> <span class="o">=</span> <span class="n">c</span><span class="p">(,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">))</span>
  <span class="c1"># Token to add the fixef for the covariate effect</span>
  <span class="p">{</span><span class="n">_COV_Cl</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span>

  <span class="n">ranef</span><span class="p">(</span><span class="n">diag</span><span class="p">(</span><span class="n">nCl</span><span class="p">,</span> <span class="n">nV</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">tokens.json</span></code></p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;_COV_Cl&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">      </span><span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="s2">&quot;&quot;</span>
<span class="w">    </span><span class="p">],</span>
<span class="w">    </span><span class="p">[</span>
<span class="w">      </span><span class="s2">&quot; * (BW/70)^dBWdCl&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="s2">&quot;\n\tfixef(dBWdCl = c(, 0.75, ))&quot;</span>
<span class="w">    </span><span class="p">]</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p><strong>Workflow Explanation:</strong> <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> will generate two models from
these files:</p>
<ol class="arabic simple">
<li><p><strong>Model 1 (Covariate Off):</strong></p>
<ul class="simple">
<li><p>It selects the first option from <code class="docutils literal notranslate"><span class="pre">_COV_Cl</span></code>: <code class="docutils literal notranslate"><span class="pre">[&quot;&quot;,</span> <span class="pre">&quot;&quot;]</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{_COV_Cl[1]}</span></code> is replaced with an empty string. The <code class="docutils literal notranslate"><span class="pre">stparm</span></code>
becomes <code class="docutils literal notranslate"><span class="pre">stparm(Cl</span> <span class="pre">=</span> <span class="pre">tvCl</span> <span class="pre">*</span> <span class="pre">exp(nCl))</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{_COV_Cl[2]}</span></code> is replaced with an empty string. No extra
<code class="docutils literal notranslate"><span class="pre">fixef</span></code> is added.</p></li>
</ul>
</li>
<li><p><strong>Model 2 (Covariate On):</strong></p>
<ul class="simple">
<li><p>It selects the second option from <code class="docutils literal notranslate"><span class="pre">_COV_Cl</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{_COV_Cl[1]}</span></code> is replaced with <code class="docutils literal notranslate"><span class="pre">&quot;</span> <span class="pre">*</span> <span class="pre">(BW/70)^dBWdCl&quot;</span></code>. The
<code class="docutils literal notranslate"><span class="pre">stparm</span></code> becomes
<code class="docutils literal notranslate"><span class="pre">stparm(Cl</span> <span class="pre">=</span> <span class="pre">tvCl</span> <span class="pre">*</span> <span class="pre">(BW/70)^dBWdCl</span> <span class="pre">*</span> <span class="pre">exp(nCl))</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">{_COV_Cl[2]}</span></code> is replaced with
<code class="docutils literal notranslate"><span class="pre">&quot;\n\tfixef(dBWdCl</span> <span class="pre">=</span> <span class="pre">c(,</span> <span class="pre">0.75,</span> <span class="pre">))&quot;</span></code>, adding the necessary fixed
effect definition.</p></li>
</ul>
</li>
</ol>
<p>The results of these two runs can then be compared to determine if
including Body Weight as a covariate on Clearance significantly improves
the model fit.</p>
<p><strong>Keywords:</strong> tokens.json, JSON, key, search space, array of arrays, options, pyDarwin</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-as-template"><span class="std std-ref">The Metamodel as a Template File</span></a></p>
</section>
<section id="directory-shortcuts-in-templates">
<h3>Directory Shortcuts in Templates<a class="headerlink" href="#directory-shortcuts-in-templates" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> supports special directory shortcuts within
the metamodel template file. These shortcuts, such as <code class="docutils literal notranslate"><span class="pre">{data_dir}</span></code>,
act as placeholders for directory paths. This allows templates to be
highly portable, as the actual paths are provided as arguments when the
<code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> search is executed, rather than being hard-coded into the
template itself.</p>
<p>Hard-coding the full path to a dataset within a metamodel
template (e.g., <code class="docutils literal notranslate"><span class="pre">##DATA</span> <span class="pre">C:/MyProject/data/pk_data.csv</span></code>) makes the
template difficult to share and reuse. Directory shortcuts solve this
problem by parameterizing the paths.</p>
<p><strong>Example:</strong> The most frequent use of these shortcuts is in the
<code class="docutils literal notranslate"><span class="pre">##DATA</span></code> block to specify the location of the input dataset.</p>
<p><strong>Hard-coded (less portable) example:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##DATA C:/Users/Me/MyProject/data/warfarin_data.csv</span>
</pre></div>
</div>
<p><strong>Using a shortcut (recommended, portable):</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##DATA {data_dir}/warfarin_data.csv</span>
</pre></div>
</div>
<p><strong>Keywords:</strong> data_dir, work_dir, output_dir, directory shortcut, path, parameterization, portable</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-as-template"><span class="std std-ref">The Metamodel as a Template File</span></a>, <a class="reference internal" href="#nlme-data"><span class="std std-ref">##DATA</span></a>, <a class="reference internal" href="#nlme-tables"><span class="std std-ref">##TABLES</span></a></p>
</section>
</section>
<section id="the-pydarwin-execution-options-file">
<span id="nlme-options"></span><h2>The pyDarwin Execution Options File<a class="headerlink" href="#the-pydarwin-execution-options-file" title="Link to this heading">¶</a></h2>
<p>To execute a <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> search with the NLME engine, the <a class="mono reference internal" href="Usage.html#options-file-target"><span class="std std-ref">options.json</span></a> file must specify the correct <code class="docutils literal notranslate"><span class="pre">engine_adapter</span></code> and provide
the paths to the NLME installation and its required compiler. <a class="reference internal" href="Options.html#options"><span class="std std-ref">Other core options</span></a> control the search algorithm, the degree of parallelism, and the penalties applied to model fitness scores.</p>
<p>The following options form the fundamental configuration for any <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> run that uses the NLME engine:</p>
<ul>
<li><div class="line-block">
<div class="line"><a class="mono reference internal" href="Options.html#engine-adapter-options-desc"><span class="std std-ref">engine_adapter</span></a> <sup>required</sup>: For NLME, it must be set to <code class="docutils literal notranslate"><span class="pre">&quot;nlme&quot;</span></code>.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><a class="mono reference internal" href="Options.html#nlme-dir-options-desc"><span class="std std-ref">nlme_dir</span></a> <sup>required</sup>: The absolute path to the NLME Engine installation directory.</div>
<div class="line">Example: <code class="docutils literal notranslate"><span class="pre">&quot;nlme_dir&quot;:</span> <span class="pre">&quot;C:/Program</span> <span class="pre">Files/Certara/NLME_Engine&quot;</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><a class="mono reference internal" href="Options.html#gcc-dir-options-desc"><span class="std std-ref">gcc_dir</span></a> <sup>required</sup>: The absolute path to the root directory of the GCC compiler used by the NLME Engine.</div>
<div class="line">Example: <code class="docutils literal notranslate"><span class="pre">&quot;gcc_dir&quot;:</span> <span class="pre">&quot;C:/Program</span> <span class="pre">Files/Certara/mingw64&quot;</span></code></div>
</div>
</li>
</ul>
</section>
<section id="pydarwin-best-practices">
<h2>pyDarwin Best Practices<a class="headerlink" href="#pydarwin-best-practices" title="Link to this heading">¶</a></h2>
<section id="the-golden-rules-of-metamodel-templates-for-pydarwin">
<h3>The Golden Rules of Metamodel Templates for pyDarwin<a class="headerlink" href="#the-golden-rules-of-metamodel-templates-for-pydarwin" title="Link to this heading">¶</a></h3>
<p>To ensure <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> can correctly parse and process
metamodel templates, several strict formatting rules MUST be followed.
Violating these rules can lead to silent parsing errors or incorrect
model generation. This entry serves as a critical checklist.</p>
<p>The following formatting rules are not optional; they are required for creating valid and robust <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> templates.</p>
<p><strong>1.</strong> <code class="docutils literal notranslate"><span class="pre">##DATA</span></code> <strong>Block MUST Be a Single Line</strong> The path to the data file
must be on the same line as the <code class="docutils literal notranslate"><span class="pre">##DATA</span></code> keyword.</p>
<ul>
<li><p><strong>Correct:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##DATA {data_dir}/my_data.csv</span>
</pre></div>
</div>
</li>
<li><p><strong>Incorrect:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##DATA</span>
  <span class="p">{</span><span class="n">data_dir</span><span class="p">}</span><span class="o">/</span><span class="n">my_data</span><span class="o">.</span><span class="n">csv</span>
</pre></div>
</div>
</li>
</ul>
<p><strong>2.</strong> <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> <strong>Block MUST Be a Single Line</strong> All column mappings in a
<code class="docutils literal notranslate"><span class="pre">##MAP</span></code> block must be on the same line as the <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> keyword,
separated by spaces or commas.</p>
<ul>
<li><p><strong>Correct:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##MAP id=Subject time=Time CObs=DV</span>
</pre></div>
</div>
</li>
<li><p><strong>Incorrect:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##MAP</span>
  <span class="nb">id</span> <span class="o">=</span> <span class="n">Subject</span>
  <span class="n">time</span> <span class="o">=</span> <span class="n">Time</span>
  <span class="n">CObs</span> <span class="o">=</span> <span class="n">DV</span>
</pre></div>
</div>
</li>
</ul>
<p><strong>3. No Comments Within</strong> <code class="docutils literal notranslate"><span class="pre">##DATA</span></code> <strong>and</strong> <code class="docutils literal notranslate"><span class="pre">##MAP</span></code> <strong>Blocks</strong> Because these
blocks must be single lines, do not attempt to add comments on the same
line.</p>
<ul>
<li><p><strong>Correct:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##Description: Model for study XYZ</span>
<span class="c1">##DATA ./data.csv</span>
<span class="c1">##MAP id=ID</span>
</pre></div>
</div>
</li>
<li><p><strong>Incorrect:</strong></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">##DATA ./data.csv # Path to the dataset</span>
<span class="c1">##MAP id=ID # Subject identifier</span>
</pre></div>
</div>
</li>
</ul>
<p><strong>4. Do NOT Place Token Syntax Inside Comments</strong> This is a
frequent source of errors. The <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> parser may attempt to
substitute tokens found within comments, leading to unpredictable
results. A comment should describe the <em>purpose</em> of a tokenized section,
but the token syntax itself (<code class="docutils literal notranslate"><span class="pre">{TOKEN[index]}</span></code>) must never appear
inside the comment.</p>
<ul>
<li><p><strong>Correct:</strong>
.. code:: pml</p>
<blockquote>
<div><p># Token for the structural model differential equations.
{_STRUCT[1]}</p>
</div></blockquote>
</li>
<li><p><strong>Incorrect:</strong>
.. code:: pml</p>
<blockquote>
<div><p># The {_STRUCT[1]} token defines the differential equations.
{_STRUCT[1]}</p>
</div></blockquote>
</li>
</ul>
<p><strong>Keywords:</strong> golden rules, best practices, checklist, template, syntax, ##DATA, ##MAP, comments, tokens, pyDarwin, formatting</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-as-template"><span class="std std-ref">The Metamodel as a Template File</span></a></p>
</section>
</section>
<section id="automated-search-of-omega-structure">
<h2>Automated Search of Omega Structure<a class="headerlink" href="#automated-search-of-omega-structure" title="Link to this heading">¶</a></h2>
<section id="searching-omega-structure-in-nlme-models">
<h3>Searching Omega Structure in NLME Models<a class="headerlink" href="#searching-omega-structure-in-nlme-models" title="Link to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> can automatically search for the optimal
variance-covariance (Omega) matrix structure for random effects. It can
test models with a simple diagonal matrix against models with various
block-diagonal structures. This search is controlled by an option in
<code class="docutils literal notranslate"><span class="pre">options.json</span></code> and a special <code class="docutils literal notranslate"><span class="pre">#search_block</span></code> directive in the
metamodel template.</p>
<p>Instead of manually creating different models to test for
correlations between random effects, you can instruct <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> to
explore these structures automatically.</p>
<section id="basic-omega-block-search">
<span id="id5"></span><h4><strong>Basic Omega Block Search</strong><a class="headerlink" href="#basic-omega-block-search" title="Link to this heading">¶</a></h4>
<p>This is the most common use case, where you want to test if a set of
random effects should be modeled as independent (diagonal matrix) or
correlated (a single block matrix).</p>
<p><strong>To enable a basic block search, you must do two things:</strong></p>
<p><strong>Step 1: Add the</strong> <code class="docutils literal notranslate"><span class="pre">#search_block</span></code> <strong>Directive to Your Template</strong></p>
<p>In your metamodel template (<code class="docutils literal notranslate"><span class="pre">.mmdl</span></code> file), add a special comment line
with the syntax <code class="docutils literal notranslate"><span class="pre">#search_block(randomEffect1,</span> <span class="pre">randomEffect2,</span> <span class="pre">...)</span></code>.
This tells <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> which random effects are candidates for the
block-diagonal search.</p>
<ul class="simple">
<li><p>This directive can be placed anywhere in the <code class="docutils literal notranslate"><span class="pre">##MODEL</span></code> block, but
it is good practice to place it near the <code class="docutils literal notranslate"><span class="pre">ranef</span></code> statements.</p></li>
<li><p>The random effects listed inside the parentheses must correspond to
names used in a <code class="docutils literal notranslate"><span class="pre">ranef</span></code> statement that defines them with a
<strong>diagonal</strong> structure.</p></li>
</ul>
<p><strong>Step 2: Enable the Search in</strong> <code class="docutils literal notranslate"><span class="pre">options.json</span></code></p>
<p>In your <code class="docutils literal notranslate"><span class="pre">options.json</span></code> file, add the following key-value pair:
<code class="docutils literal notranslate"><span class="pre">&quot;search_omega_blocks&quot;:</span> <span class="pre">true</span></code></p>
<p><strong>How It Works: An Example</strong></p>
<p>Imagine your metamodel template has the following <code class="docutils literal notranslate"><span class="pre">ranef</span></code> statement
and <code class="docutils literal notranslate"><span class="pre">search_block</span></code> directive:</p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span># template.mmdl snippet
...
ranef(diag(nCl, nV) = c(0.09, 0.09))
#search_block(nCl, nV)
...
</pre></div>
</div>
<p>And your <code class="docutils literal notranslate"><span class="pre">options.json</span></code> contains <code class="docutils literal notranslate"><span class="pre">&quot;search_omega_blocks&quot;:</span> <span class="pre">true</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> will automatically generate and test <strong>two</strong> different
models:</p>
<ol class="arabic">
<li><p><strong>Model 1 (Diagonal):</strong> The <code class="docutils literal notranslate"><span class="pre">ranef</span></code> statement is left as is,
modeling no correlation.</p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>ranef(diag(nCl, nV) = c(0.09, 0.09))
</pre></div>
</div>
</li>
<li><p><strong>Model 2 (Block):</strong> <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> automatically creates a
block-diagonal structure for the searched effects.</p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>ranef(block(nCl, nV) = c(0.09, 0, 0.09))
</pre></div>
</div>
</li>
</ol>
<p><strong>Important Rules and Restrictions:</strong></p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">#search_block</span></code> directive must only contain a comma-separated
list of random effect names. No other comments or syntax are allowed
inside the parentheses.</p></li>
<li><p>Only random effects defined in a <code class="docutils literal notranslate"><span class="pre">diag()</span></code> context can be
included in a <code class="docutils literal notranslate"><span class="pre">#search_block</span></code>. You cannot search effects that are
already part of a <code class="docutils literal notranslate"><span class="pre">block()</span></code>, <code class="docutils literal notranslate"><span class="pre">same()</span></code>, or <code class="docutils literal notranslate"><span class="pre">fixed</span></code> structure.</p></li>
<li><p>If a random effect is dependent on another (e.g.,
<code class="docutils literal notranslate"><span class="pre">ranef(diag(nCl),</span> <span class="pre">same(nOther))</span></code>), you cannot include <code class="docutils literal notranslate"><span class="pre">nCl</span></code> in
the search block.</p></li>
</ul>
</section>
<section id="advanced-search-with-submatrices">
<span id="id6"></span><h4><strong>Advanced Search with Submatrices</strong><a class="headerlink" href="#advanced-search-with-submatrices" title="Link to this heading">¶</a></h4>
<p>This feature expands the search beyond the simple “all diagonal vs. one
big block” paradigm. It allows <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> to test various combinations
of smaller block matrices within the searched effects, which can be
useful for identifying specific correlation patterns without
over-parameterizing the model.</p>
<p><strong>To enable a submatrix search, add two options to</strong> <code class="docutils literal notranslate"><span class="pre">options.json</span></code></p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;search_omega_sub_matrix&quot;:</span> <span class="pre">true</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">&quot;max_omega_sub_matrix&quot;:</span> <span class="pre">N</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is an integer for the
maximum size of any sub-block to be considered (e.g., 2 or 3).</p></li>
</ol>
<p><strong>How It Works: An Example</strong></p>
<p>Consider a search on four random effects:</p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span># template.mmdl snippet
ranef(diag(nCl, nV, nKa, nF) = c(1,1,1,1))
#search_block(nCl, nV, nKa, nF)
</pre></div>
</div>
<p>And your <code class="docutils literal notranslate"><span class="pre">options.json</span></code> contains:</p>
<div class="highlight-json notranslate"><div class="highlight"><pre><span></span><span class="nt">&quot;search_omega_blocks&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="nt">&quot;search_omega_sub_matrix&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span>
<span class="nt">&quot;max_omega_sub_matrix&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> will now test a much larger set of possible Omega
structures. In addition to the full diagonal and the single 4x4 block,
it will also test patterns like:</p>
<ul>
<li><p><strong>Pattern A: One 2x2 block</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>ranef(block(nCl, nV) = c(1,0,1))
ranef(diag(nKa, nF) = c(1,1))
</pre></div>
</div>
</li>
<li><p><strong>Pattern B: A different 2x2 block</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>ranef(diag(nCl) = c(1))
ranef(block(nV, nKa) = c(1,0,1))
ranef(diag(nF) = c(1))
</pre></div>
</div>
</li>
<li><p><strong>Pattern C: Two separate 2x2 blocks</strong></p>
<div class="highlight-pml notranslate"><div class="highlight"><pre><span></span>ranef(block(nCl, nV) = c(1,0,1))
ranef(block(nKa, nF) = c(1,0,1))
</pre></div>
</div>
</li>
</ul>
<p>…and all other valid combinations. <code class="docutils literal notranslate"><span class="pre">pyDarwin</span></code> automatically
generates this entire search space of patterns based on the parameters
in the <code class="docutils literal notranslate"><span class="pre">#search_block</span></code> and the <code class="docutils literal notranslate"><span class="pre">max_omega_sub_matrix</span></code> setting.</p>
<p><strong>Keywords:</strong> Omega search, search_omega_blocks, #search_block, ranef,
block, diag, search_omega_sub_matrix, max_omega_sub_matrix, pyDarwin,
NLME, variance-covariance</p>
<p><strong>See also:</strong> <a class="reference internal" href="#nlme-metamodel-as-template"><span class="std std-ref">The Metamodel as a Template File</span></a>, <a class="reference internal" href="#nlme-options"><span class="std std-ref">The options.json File</span></a>, <a class="mono reference internal" href="#nlme-ranef"><span class="std std-ref">ranef</span></a></p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Troubleshooting.html" class="btn btn-neutral float-left" title="Troubleshooting" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Mark Sale, Certara.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>