<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Required Files &mdash; pyDarwin 1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PK Model 1, trivial exhaustive search" href="PKModel1.html" />
    <link rel="prev" title="ML Model Selection, Theory and implementation" href="Theory.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pyDarwin
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="Theory.html">ML Model Selection, Theory and implementation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Required Files</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-template-file">The Template File</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-tokens-file">The Tokens File</a></li>
<li class="toctree-l2"><a class="reference internal" href="#options-file">Options File</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="PKModel1.html">PK Model 1, trivial exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="PKModel2.html">PK Model 2, Simulation model by GP with Python code</a></li>
<li class="toctree-l1"><a class="reference internal" href="PKModel3.html">PK Model 3, ODE model</a></li>
<li class="toctree-l1"><a class="reference internal" href="PKModel4.html">PK Model 4, DMAG by GA</a></li>
<li class="toctree-l1"><a class="reference internal" href="API.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="Glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="Support.html">Support</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyDarwin</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Required Files</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/Required_files.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="required-files">
<h1>Required Files<a class="headerlink" href="#required-files" title="Permalink to this heading">¶</a></h1>
<p id="startrequiredfiles">The same 3 files are required for any search, whether exhausitve, GA, GP, RF or GBRF. Which algorithm is used is defined in the <a class="reference internal" href="Glossary.html#options-file"><span class="std std-ref">options file</span></a>. The template
file serves as a framework, and looks similar to a NONMEM/NMTRAN control file. The tokens file specifies the range of “features” to be searched, and the options
file specifies the algorithm, the fitness function, any R or Python code to be executed after the NONMEM execution etc.</p>
<section id="the-template-file">
<span id="id1"></span><h2>The Template File<a class="headerlink" href="#the-template-file" title="Permalink to this heading">¶</a></h2>
<p>The template file is a plain ASCII text file. This file is the framework for the construction of the NONMEM control files.
Typically, the structure will be quite similar to a NONMEM control file, with all of the
usual blocks, e.g. $PROB, $INPUT, $DATA, $SUBS, $PK, $ERROR, $THETA, $OMEGA, $SIGMA, $EST. However, this format is
completely flexible and entire blocks may be missing from the template file (to be provided from the <a class="reference internal" href="#tokens-file">tokens file</a>)</p>
<p>The difference between a standard NONMEM control file and the temlate file is that the user will define code
segments in the template file that will be replaced by other text. These code segments are refered to as “token keys”.
Tokens keys come in sets, as in most case several code segements will need to be replace together to generate syntacatically
correct code. The syntax for a token key in the template file is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">Token_stem</span><span class="p">[</span><span class="n">N</span><span class="p">]}</span>
</pre></div>
</div>
<p>Where Token_stem is a unique identified for that token set and N is which target text is to be substituted. An
example is useful.</p>
<p>Assume the user would like to consider 1 compartment (ADVAN1) and 2 compartment (ADVAN3) models as candidates for the structural model.
The relevant template file for this might be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$SUBS {ADVAN[1]}
.
.
$PK
.
.
.
{ADVAN[2]}
.
.
.
$THETA
(0,1) ; Volume - fixed THETA - always appears
(0,1) ; Clearance - fixed THETA - always appears
{ADVAN[3]}
</pre></div>
</div>
<p>Note that tokens nearly always come in sets, as in nearly all cases, several substitions must be made to create correct syntax.
For a one compartment model the following substutions would be made:</p>
<p>{ADVAN[1]} -&gt; ADVAN1</p>
<p>{ADVAN[2]} -&gt; ;; 1 compartment</p>
<p>{ADVAN[3]} -&gt; ;; 1 compartment</p>
<p>and for 2 compartment:</p>
<p>{ADVAN[1]} -&gt; ADVAN3</p>
<p>{ADVAN[2]} -&gt; K = THETA(?) ;; 2 compartment</p>
<p>{ADVAN[3]} -&gt;(0,0.5)) ;; 2 compartment non fixed THETA</p>
<p>These sets of tokens are called tokens sets (2 tokens sets in this example one for ADVAN1, one for ADVAN3). The group of token sets
is called a token group. In this example “ADVAN” is the token key. Each token group must have a unique token key. For the first set of options the text “ADVAN1” is refered to as
the token text. Each token set consists of key-text pairs:</p>
<p>token keys (described above) and</p>
<p>token text</p>
<p>The token, (consisting of “{” + token stem +[n] + “}” where n is an integer index) in the template file is replaced by the token text,
specified in the tokens file. Which set of token key-text pairs is substitituted is determined by the search algorithm, and provides in
the <a class="reference internal" href="Glossary.html#phenotype"><span class="std std-ref">phenotype.</span></a></p>
<p>Note that the THETA (and ETA and EPS) indices cannot be determined until the final control file is defined, as THETAs may be included in one and not another.
For this reason, all fixed initial estimates in the $THETA block MUST occur before the THETA values that are not fixed. This is so the
algorithm can parse the resulting file and correctly calculate the appropriate THETA (and ETA and EPS) indices.
Note that the permited syntax for residual error is EPS() or ERR().</p>
<p>Special notes on strucutre of $THETA/$OMEGA/$SIGMA:</p>
<p>Parameter initial estimate blocks require special treatment. A template file will typically include 2 types of initial estimates:</p>
<ol class="arabic simple">
<li><p>Fixed initial estimates - Initial estimates that are not searched, but will be copied from the template into <strong>ALL</strong> control files. These are the typical $THETA estimates, e.g.: (0,1)  ; THETA(1) Clearance.</p></li>
<li><p>Searched initial estimates - Initial estimates that are specified in tokens that may or may not be in any given control file. e.g.,: {ALAG[2]} where the text for the ALAG[2] token key is “(0,1) ;; THETA(ALAG) Absorption lag time”</p></li>
</ol>
<p>There are 3 restriction for the parseing of the initial estimates blocks:</p>
<ol class="arabic simple">
<li><p>Fixed initial estimates <strong>MUST</strong> be placed before Searched Initial estimates.</p></li>
<li><p>Each parameter initial estimate must be one a separate line</p></li>
<li><p>Text for <strong>ALL</strong> initial estimates must be in parentheses, e.g., (1), or (0,1) or (0,1,5)</p></li>
</ol>
</section>
<section id="the-tokens-file">
<span id="tokens-file"></span><h2>The Tokens File<a class="headerlink" href="#the-tokens-file" title="Permalink to this heading">¶</a></h2>
<p>The tokens file provide a dictionary (as a JSON file) of token key-text pairs. The highest level of the dictionary is the <a class="reference internal" href="Glossary.html#token-group"><span class="std std-ref">token group</span></a>. Token groups are
defined by a unique <a class="reference internal" href="Glossary.html#token-stem"><span class="std std-ref">token stem</span></a>. The token stem also serves as the key in the <a class="reference internal" href="Glossary.html#token-key-text-pair"><span class="std std-ref">tokenn key-text pairs.</span></a> The token stem is a text string that corresponds to the token key that appears in the <a class="reference internal" href="Glossary.html#template"><span class="std std-ref">template file</span></a>.
The 2nd level in the tokens dictionary are the <a class="reference internal" href="Glossary.html#token-set"><span class="std std-ref">token sets</span></a>. In the template file the tokens are indexed (e.g., ADVAN[1]), as typically multiple token keys will be to be
replace by text to create correct syntax. For example, if the search if for 1 compartment (ADVAN1) vs 2 compartment (ADVAN3), for ADVAN3, definitions of K23 and K32 must be provided
in the $PK block, and (typically) initial estimates must be provided in the $THETA block. Thus, a set of 3 replacements must be made, one in $SUBS, one in $PK and one in
$THETA. So, the token set for selection of number of compartments will, for 1 compartment (first option) or 2 compartments (second option),
will include the following JSON code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="s2">&quot;ADVAN&quot;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">[</span><span class="s2">&quot;ADVAN1 ;; advan1&quot;</span><span class="p">,</span>
                <span class="s2">&quot;;; PK 1 compartment &quot;</span><span class="p">,</span>
                <span class="s2">&quot;;; THETA 1 compartment&quot;</span>
            <span class="p">],</span>
            <span class="p">[</span><span class="s2">&quot;ADVAN3 ;; advan3&quot;</span><span class="p">,</span>
                <span class="s2">&quot; K23=THETA(ADVANA){K23~WT[1]}</span><span class="se">\n</span><span class="s2"> K32=THETA(ADVANB){K23~WT[1]}&quot;</span><span class="p">,</span>
                <span class="s2">&quot;  (0.001,0.02)  </span><span class="se">\t</span><span class="s2"> ;; THETA(ADVANA) K23 </span><span class="se">\n</span><span class="s2"> (0.001,0.3) </span><span class="se">\t</span><span class="s2"> ;; THETA(ADVANB) K32 </span><span class="se">\n</span><span class="s2">{K23~WT[2]} </span><span class="se">\t</span><span class="s2"> ;; init for K23~WT &quot;</span>
            <span class="p">],</span>
</pre></div>
</div>
<p>Note that whether the current model is one compartment or two is selected by the search algorithm and provided in the model <a class="reference internal" href="Glossary.html#phenotype"><span class="std std-ref">phenotype</span></a>.</p>
<p>A diagram of the token structure is given below</p>
<figure class="align-default">
<img alt="_images/tokens.png" src="_images/tokens.png" />
</figure>
<p>Note the “nested token” - a token (“{K23~WT[1]}”) within a token, circled in red. One level of nested tokens is permited. pyDarwin will first substitute the full text
into the template, then scans the resulting text again. This nested token will then be found and the text from the {K23~WT[1]} token set will be substituted.</p>
<p>Several notes:</p>
<ol class="arabic simple">
<li><p>The <a class="reference internal" href="Glossary.html#token-stem"><span class="std std-ref">token stem</span></a> is “ADVAN” and identifies the <a class="reference internal" href="Glossary.html#token-group"><span class="std std-ref">token group</span></a>. This stem must be unique in the tokens groups. The token stem also  serves as the token key in the <a class="reference internal" href="Glossary.html#token-key-text-pair"><span class="std std-ref">token key-value pairs</span></a>. In this example, three replacements must be made in the template, in $SUBS, $PK and $THETA. In the template file, these will be coded as {ADVAN[1]}, {ADVAN[2]} and {ADVAN[3]}. Note the curly braces, these are required in the template, but not the tokens file. The indices correspond to the indices of the <a class="reference internal" href="Glossary.html#token"><span class="std std-ref">tokens</span></a> in the token set. In this case there are 3 <a class="reference internal" href="Glossary.html#token-key-text-pair"><span class="std std-ref">token key-value pairs</span></a> in each token set. There may be additional unused tokens (as may be the case with <a class="reference internal" href="Glossary.html#nested-tokens"><span class="std std-ref">nest tokens</span></a>, but each token in the template file must have a corresponding token key-value pair in the tokens file. 2 token sets in this token group, one coding for ADVAN1 and one coding for ADVAN3.</p></li>
<li><p>New lines in JSON files are ignored. To code a new line, enter the newline escape character “\n”. Similarly, a tab is coded as “\t”.</p></li>
<li><p>Comments are not permitted in JSON files. However comments for the generated NMTRAN control file maybe included with the usual syntax “;”.</p></li>
<li><p>There is no dependency on the sequence of token sets in the file, any order is acceptable, they need not be in the same order as they appear in the <a class="reference internal" href="#the-template-file"><span class="std std-ref">template file.</span></a></p></li>
<li><p>All other JSON (<a class="reference external" href="https://www.json.org/json-en.html">JSON</a> ) rules apply.</p></li>
</ol>
</section>
<section id="options-file">
<span id="the-options-file"></span><h2>Options File<a class="headerlink" href="#options-file" title="Permalink to this heading">¶</a></h2>
<p>Note that the the options are saved to a json file. Json supports string, numeric and Boolen (true|false)
Options include</p>
<p>author: String, Author, currently not used, Default - blank</p>
<p>homeDir: String, Linux style for the home directory, generation/interation subfolders will be placed here, Required</p>
<p>algorithm: String, Required GA (
<a class="reference internal" href="Theory.html#genetic-algorithm"><span class="std std-ref">Genetic Algorithm</span></a> ) EX (
<a class="reference internal" href="Theory.html#exhaustive-search"><span class="std std-ref">Exhaustive Search</span></a> ) GP (
<a class="reference internal" href="Theory.html#gaussian-process-bayesian-optimization"><span class="std std-ref">Gaussian Process</span></a> ) RF (
<a class="reference internal" href="Theory.html#random-forest"><span class="std std-ref">Random Forest</span></a>  ) GBRT (
<a class="reference internal" href="Theory.html#gradient-boosted-random-tree"><span class="std std-ref">Gradient Boosted Random Tree</span></a>). Which algorithm to use.</p>
<p>random_seed: Integer, required if using GA/GP/RF or GBRT,</p>
<p>population_size: Integer, required if using algorithm other than exhaustive search</p>
<p>nmfePath: String, required, path to nmfe??.bat file. Currently supported are nmfe74.bat and nmfe75.bat.</p>
<p>num_parallel: Integer, optional. Number of NONMEM models to run in parallel, Default = 4</p>
<p>num_generations: Integer, required if using GA/GP/RF or GBRT</p>
<p>niche_penalty: Numeric, required if using GA. Require for calculation of the crowding penalty.
The niche penalty is calculate by first calculating the “distance matrix”, the pair wise Mikowski distance (<a class="reference external" href="https://en.wikipedia.org/wiki/Minkowski_distance">https://en.wikipedia.org/wiki/Minkowski_distance</a>) from the present model to all other models in the generation.
The “crowding” quantity is then calculated a the sum of:
1 - (distance/niche_radius)**sharing_alpha for all other models in the generation for which the Mikowski distance is less than the niche radius.
Finally, the penalty is calculated as:
exp((crowding-1)*niche_penalty)-1
The objective of using a niche penalty is to maintain diversity of models, to avoid premature convergence of the search, by penalizing when models are too
similar to other models in the current generation.
A typical value for the penalty is 10.</p>
<p>num_niches: Integer, required if using GA.</p>
<p>niche_radius: Numeric, required if using GA. A typical value for niche_radius is 2.</p>
<p>THETAPenalty: Numeric, required</p>
<p>OMEGAPenalty: Numeric, required</p>
<p>SIGMAPenalty: Numeric, required</p>
<p>conditionNumberPenalty: Numeric, required</p>
<p>covariancePenalty: Numeric, required</p>
<p>covergencePenalty: Numeric, required</p>
<p>correlationLimit: Numeric, required</p>
<p>correlationPenalty: Numeric, required. Penalty if the absolute value of any off diagonal of the OMEGA matrix exceeds correlationLimit</p>
<p>crash_value: numeric, required. The fitness/reward value to assign to a model that fails to complete. Typical value is 99999999, should be larger than that
expected from any model that does complete.</p>
<p>crossoverRate: 0.95,</p>
<p>downhill_q:5,</p>
<p>elitist_num: 4,</p>
<p>mutationRate: 0.95,</p>
<p>attribute_mutation_probability: 0.1,</p>
<p>input_model_json: None,</p>
<p>max_model_list_size: Integer, required. The algorithm generates models in batches. For exhausitve search in particular, this may result in a very large number of
model (100,000’s?). This can lead to memory issues with a very large array of large objects. To address this, the user can (and should) define that only a
limited number of models will be gnerated at a time, all those model run, then the list recreated. A typical value for a capable computer is 10,000.</p>
<p>mutate: string, required for GA. What method to use for mutation, only available option is flipBit</p>
<p>non_influential_tokens_penalty: 0.00001,</p>
<p>remove_run_dir: Boolean, options (false), Delete entire run directory. By default, all F*, WKS* file, the executable file and other non-essential files will be deleted.
NONMEM $TABLE files (unless deleted as F* or WKS*) will be retained. If large $TABLE files are written for each run, a great deal of disk space can be required. If $TABLE
file are needed to postRunRCode, they can be deleted in the user provided R code to preserve disc space.</p>
<p>fullExhaustiveSearch_qdownhill: Boolean, required. The option exists to run a local exhausitve search with 2 bit radius after each dowhill search. Note that for large dimension
search space, this can be time consuming. The number of models in each step is (dimension*dimension)/2 + dimension/2, where dimension is the number of bits Required
to define the search space.</p>
<p>final_fullExhaustiveSearch:  Boolean, required. The option exists to run a local exhausitve search with 2 bit radius at the end of the search. Note that for large dimension
search space, this can be time consuming. The number of models in each step is (dimension*dimension)/2 + dimension/2, where dimension is the number of bits Required
to define the search space.</p>
<p>selection: string, required for GA. The algorithm used for the selection step in GA, only currently available algorithm is tournament.</p>
<p>selection_size: integer, required for GA. How many “parents” to select for the tournament</p>
<p>sharing_alpha: 0.1,</p>
<p>timeout_sec: numeric (seconds), optional(1200);. NONMEM run will be terminated (and result will be CRASH) if run time exceeds this.</p>
<p>useR: boolean, optional (false). Whether to call user provided R code after each NONMEM run. If true, postRunRCode must provide path to R code</p>
<p>postRunRCode: string, required if useR is true. Path to R code to be run after each NONMEM run. Required return values a vector of
length 2. The first will be a numeric (or character that can be cast as numeric) that will be added to the fitness/reward values. The 2nd is a character
string that will be appended to the NONMEM output file.</p>
<p>usePython: boolean, optional (false). Whether to call user provided Python code after each NONMEM run. If true, postRunPythonCode must provide path to R code</p>
<p>postRunPythonCode: string, required if usePython is true.
crossoverOperator: cxOnePoint ,</p>
<p>NM_priority_class: string, optional, default = normal. Recommended to maintain interface responsiveness is below_normal,</p>
<p>search_omega_bands: false,</p>
<p>max_omega_band_width: integer, required if seach_omega_bands is true. Unfortunately is was not possible to query the temlate file and token groups to, in general,
determine the maximum size of all $OMEGA blocks. Therefore, the user is required to provide the maximum number of off diagonal bands that would be searched. This is
required to determine the number of bits to be included in the bit string/search space.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="Theory.html" class="btn btn-neutral float-left" title="ML Model Selection, Theory and implementation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="PKModel1.html" class="btn btn-neutral float-right" title="PK Model 1, trivial exhaustive search" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, ms.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>